/* Generated By:JJTree: Do not edit this line. ASTCall.java Version 4.3 */
/*
 * JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,
 * NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true
 */
package org.dojo.jsl.parser.ast;

import java.util.HashMap;

import org.dojo.jsl.parser.ast.utils.LaraCNodeFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

import larac.objects.Enums.AssignOperator;
import larac.objects.Enums.Types;
import larac.objects.Variable;
import larac.utils.output.MessageConstants;
import larac.utils.xml.AspectIRFactory;

public class ASTCall extends SimpleNode {
    private String aspName;
    private String aspVarName;
    private SimpleNode leftHandSideExpression;

    private Variable aspectDeclaration;
    private ASTFunctionCallParameters args;

    public ASTCall(int id) {
        super(id);
    }

    public ASTCall(LARAEcmaScript p, int id) {
        super(p, id);
    }

    /**
     * @param aspName
     *            the aspName to set
     */
    public void setAspName(String aspName) {
        this.aspName = aspName;
    }

    /**
     * @return the aspName
     */
    public String getAspName() {
        return aspName;
    }

    public String getAspVarName() {
        return aspVarName;
    }

    public void setAspVarName(String aspVarName) {
        this.aspVarName = aspVarName;
    }

    @Override
    public Object organize(Object obj) {
        String path = aspName;
        if (children != null) {

            int pos = 0;
            // If first child is not a list of parameters OR a path to the aspect
            if (!(getChild(pos) instanceof ASTFunctionCallParameters || getChild(pos) instanceof ASTFilePath)) {
                // Then is a lefthandside expression
                getChild(pos).organize(obj);
                // If it is a simple identifier then we are declaring a new variable
                if (jjtGetChild(pos) instanceof ASTIdentifier) {
                    aspVarName = ((ASTIdentifier) jjtGetChild(pos)).getName();
                } else { // otherwise it is some kind of composite reference
                    leftHandSideExpression = getChild(pos);
                }
                pos++;
            }
            // If it has more children
            if (pos < children.length) {
                // if we have a filepath means that we are statically accessing an aspect
                if (jjtGetChild(pos) instanceof ASTFilePath) {
                    final ASTFilePath filePath = (ASTFilePath) jjtGetChild(pos);
                    path = "";
                    // Concatenate the path to the aspect
                    for (final Node child : filePath.getChildren()) {
                        path += ((ASTIdentifier) child).value.toString() + MessageConstants.NAME_SEPARATOR;
                    }
                    path += aspName;
                    pos++;
                }
                // If more children then these are the arguments
                if (pos < children.length) {
                    args = (ASTFunctionCallParameters) jjtGetChild(pos);
                    args.organize(obj);
                }
            }
        }
        // Verify if the called aspect exists
        aspectDeclaration = lookup(path);

        // System.out.println(path + "->" + aspectDeclaration);
        if (aspectDeclaration == null && !getLara().getOptions().isDocumentationMode()) {
            throw newException("Called aspect/variable does not exist: \"" + aspName + "\"");
        }
        Types aspectType = aspectDeclaration.getType();

        /*
        	// and if it is indeed an aspect
        	if (!(aspectType.equals(Types.Aspect) || aspectType.equals(Types.AspectSTATIC))) {
        	    throw newException("Called variable is not an aspect: \"" + aspName + "\" is of type: " + aspectType);
        	}
        */
        // If we have a variable declaration then we should add it to the symbol table
        if (aspVarName != null) {

            final HashMap<String, Variable> vars = getHMVars();
            // if (vars.containsKey(aspVarName))
            // throw newException("Variable '" + aspVarName + "' already defined
            // on this scope");
            if (!vars.containsKey(aspVarName)) {
                getHMVars().put(aspVarName, new Variable(aspVarName, aspectType));
            }
        }
        /*
         * 
         * else{ LaraC lara = getLara(); ASTAspectDef asp =
         * lara.getAspectDef(aspName); if(asp == null){ asp =
         * lara.getImportedAspectDef(aspName); if(asp == null) throw
         * newException("The aspect does not exist: "+aspName); } }
         * SymbolTable<String,Variable> vars = (SymbolTable<String, Variable>)
         * getHMVars(); this.var = new
         * Variable(vars.getUniqueName("FRONTEND_CALL_ASPECT_"+aspName),Types.
         * ASPECT); if(getChildren() == null || getChildren()[0] instanceof
         * ASTFunctionCallParameters){ Variable var = lookupNoError(aspName);
         * 
         * } return null; }
         * 
         * LaraC lara = getLara(); ASTAspectDef asp =
         * lara.getImportedAspectDef(path); if(asp == null) throw newException(
         * "The aspect does not exist: "+path); SymbolTable<String,Variable>
         * vars = (SymbolTable<String, Variable>) getHMVars(); this.var = new
         * Variable(vars.getUniqueName("FRONTEND_CALL_ASPECT_"+aspName),Types.
         * ASPECT);
         */
        return null;
    }

    @Override
    public void toXML(Document doc, Element parent) {
        // System.out.println("AspectDeclName: " + aspectDeclaration.getName());
        // System.out.println("AspectDeclType: " + aspectDeclaration.getType());

        String varName = aspectDeclaration.getName();
        // if (aspectDeclaration.getType() == Types.AspectSTATIC) {
        // If using a complex LHS, then wrap the call with an assignment
        if (leftHandSideExpression != null) {
            final Element statementEl = doc.createElement("statement");
            statementEl.setAttribute("coord", getCoords());
            statementEl.setAttribute("name", "expr");
            parent.appendChild(statementEl);
            final Element exprEl = doc.createElement("expression");
            statementEl.appendChild(exprEl);
            final Element assignEl = doc.createElement("op");
            assignEl.setAttribute("name", AssignOperator.ASSIGN.name());
            exprEl.appendChild(assignEl);
            leftHandSideExpression.toXML(doc, assignEl);
            if (aspectDeclaration.getType().equals(Types.AspectSTATIC)) {
                ASTAllocationExpression allocExpr = LaraCNodeFactory.newAllocExpr(aspectDeclaration.getName());
                allocExpr.toXML(doc, assignEl);
            } else {
                aspectDeclaration.toXML(doc, assignEl);
            }

        }
        // This 'if' assumes all code is present, and that we can obtain the declaration of any aspect
        // However, for separate compilation this is not the case.
        // Assume that all calls are made over aspects
        else if (aspectDeclaration.getType().equals(Types.AspectSTATIC) || true) {

            if (aspVarName != null) {
                varName = aspVarName;
            } else {
                varName = aspectDeclaration.getName() + aspectDeclaration.staticName
                        + aspectDeclaration.staticCounter++;
            }

            SimpleNode initExpr = LaraCNodeFactory.newAllocExpr(aspectDeclaration.getName());
            // if (aspectDeclaration.getType().equals(Types.AspectSTATIC)) {
            // } else {
            // initExpr = LaraCNodeFactory.newIdentifier(aspectDeclaration.getName());
            // }
            AspectIRFactory.varDeclStmtToXML(doc, parent, varName, initExpr, getCoords(), null);

            /*
            final Element statementEl = doc.createElement("statement");
            statementEl.setAttribute("coord", getCoords());
            statementEl.setAttribute("name", "vardecl");
            parent.appendChild(statementEl);
            
            if (aspectDeclaration.getType().equals(Types.AspectSTATIC)) {
            ASTAllocationExpression allocExpr = newAllocExpr(aspectDeclaration.getName());
            allocExpr.toXML(doc, statementEl);
            } else {
            aspectDeclaration.toXML(doc, statementEl);
            }*/
        }

        // }
        final Element statementEl = doc.createElement("statement");
        statementEl.setAttribute("name", "expr");
        statementEl.setAttribute("coord", getCoords());
        parent.appendChild(statementEl);
        final Element expressionEl = doc.createElement("expression");
        statementEl.appendChild(expressionEl);
        final Element callEl = doc.createElement("call");
        expressionEl.appendChild(callEl);
        final Element methodEl = doc.createElement("method");
        callEl.appendChild(methodEl);
        final Element propEl = doc.createElement("property");
        methodEl.appendChild(propEl);
        if (leftHandSideExpression != null) {
            leftHandSideExpression.toXML(doc, propEl);
        } else {
            AspectIRFactory.idRef(doc, propEl, varName);
        }
        final Element litCallEl = doc.createElement("literal");
        litCallEl.setAttribute("type", Types.String.toString());
        litCallEl.setAttribute("value", "call");
        propEl.appendChild(litCallEl);
        if (args != null) {
            args.toXML(doc, callEl);
        }
        // aspectDeclaration.setName(varName);
    }

    @Override
    public String toString() {
        return LARAEcmaScriptTreeConstants.jjtNodeName[id] + " [" + aspName + "]";
    }
}
/*
 * JavaCC - OriginalChecksum=435ab740a3ff136aeff8f583fff894e4 (do not edit this
 * line)
 */
