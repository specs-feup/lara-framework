/*
 * Copyright 2020 SPeCS.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License. under the License.
 */
 

options {
 
	/*
	 * Default value is true. If true, all methods and class variables 
	 * are specified as static in the generated parser and token manager. This allows only 
	 * one parser object to be present, but it improves the performance of the parser.
	 */
	STATIC = false;

	/*
	 * Options for obtaining debugging information
	 */
	DEBUG_PARSER = false;

	DEBUG_TOKEN_MANAGER = false;

	/*
	 * Default value is false. When set to true, the generated parser 
	 * uses an input stream object that processes Java Unicode escapes before 
	 * sending characters to the token manager. 
	 */
	JAVA_UNICODE_ESCAPE = true;

	/*
	 * Default value is false. When set to true, the generated parser 
	 * uses uses an input stream object that reads Unicode files. By default, ASCII files 
	 * are assumed. 
	 */
	UNICODE_INPUT = true;

	/*
	 * Default value is false. Generate a multi mode parse tree. 
	 * The default for this is false, generating a simple mode parse tree.
	 */
	MULTI=true;

	/*
	 * Default value is false. Instead of making each non-decorated 
	 * production an indefinite node, make it void instead.
	 */
	NODE_DEFAULT_VOID=true;

	/*
	 * The package to generate the node classes into. 
	 */
	NODE_PACKAGE = "pt.up.fe.specs.lara.parser.javacc.ast";

	/*
	 * The output directory for the generated classes
	 */
	JJTREE_OUTPUT_DIRECTORY = "ast";
 
	/*
	 * Default value is false. Insert a jjtAccept() method in the 
	 * node classes, and generate a visitor implementation with an entry for every 
	 * node type used in the grammar.
	 */
	VISITOR=false;

	/*
	 * Default value is false. Insert calls to user-defined parser 
	 * methods on entry and exit of every node scope. See Node Scope Hooks above.
	 */
	NODE_SCOPE_HOOK=false;
	TRACK_TOKENS = true; //sets first and last token of the node
	/*
	 * JDK Version
	 */
	JDK_VERSION = "1.8";

	/*
	 * Ignore case for keywords
	 */
	//IGNORE_CASE = true;
}

PARSER_BEGIN(LARAEcmaScript)

package pt.up.fe.specs.lara.parser.javacc.ast;

import java.io.*;
import java.util.*;
import java.io.File;
import java.io.FileReader;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;

public class LARAEcmaScript extends LARAParserBase{
  	private static final int MAX_EXCEPTION_TOKEN_SIZE = 6;
    private static final int MAXIMUM_SYNTAX_EXCEPTIONS = 5;
  	
  	public File inputAspectFile = null;
  	public FileReader inputAspectFr = null;
  	public BufferedReader inputAspectBr = null;
    public List<Throwable> exceptions = new ArrayList<Throwable>() ;
    private int exprBraceCount = 0;

	public ASTExpressionStatement parseExpression(String expression) throws ParseException{
		 return ParseExpression();
	}
	
	public ASTStart parse() throws ParseException{
	      this.exceptions = new ArrayList<Throwable>(); 
	
	      return this.Start();
	}

  	/* Old Code */
	@Deprecated
	public static ASTStart parseFile(String fileName){
    	return parseFile(new File(fileName));
		}
  	@Deprecated
	public static ASTStart parseFile(File laraFile){
	    ASTStart start = null;
	    File inputAspectFile = laraFile;
		FileReader inputAspectFr = null;
		BufferedReader inputAspectBr = null;
	    try{
		  inputAspectFr = new FileReader(inputAspectFile);
		  inputAspectBr = new BufferedReader(inputAspectFr);
	      LARAEcmaScript aspectParser = new LARAEcmaScript(inputAspectBr);
	      start = aspectParser.Start();
	    }
	    catch (Exception e)
	    {
	      try {
		    if(inputAspectFr != null)
			inputAspectFr.close();
		    if(inputAspectBr != null)
			inputAspectBr.close();
		} catch (IOException e1) {
				throw new RuntimeException(e1);
		}
	    }

	     try {
		    if(inputAspectFr != null)
			inputAspectFr.close();
		    if(inputAspectBr != null)
			inputAspectBr.close();
		    
		} catch (IOException e1) {
		    throw new RuntimeException(e1);
		}
	   return start;
  }
	
}
PARSER_END(LARAEcmaScript)

TOKEN_MGR_DECLS : { 
	public int htmlTokenNestingLevel = 0;
	public boolean expectActionScript = false;
}


/*****************************************
 * LEXICAL & REGEXP GRAMMARS STARTS HERE *
 *****************************************/


/* Section 7 : Lexical Conventions */

/* Section 7.2 : White Space */

<DEFAULT, IN_REGEX>
SKIP: //SPECIAL_TOKEN :
{
	<WHITE_SPACE: <TAB> | <VT> | <FF> | <SP> | <NBSP> >
| 
	< #TAB: "\u0009" | "\t" > /* TAB */
|
	< #VT: "\u000B" > /* Vertical Tab */
| 
	< #FF: "\u000C" | "\f"> /* Form Feed */
| 
	< #SP: "\u0020" | " " > /* Space */
| 
	< #NBSP: "\u00A0" > /* No-break space */
| 
	< #USP: /* Other Unicode space seperator */
		["\u2000"] 
		| ["\u2001"] 
		| ["\u2002"] 
		| ["\u2003"] 
		| ["\u2004"] 
		| ["\u2005"] 
		| ["\u2006"] 
		| ["\u2007"]
		| ["\u2008"] 
		| ["\u2009"] 
		| ["\u200A"] 
		| ["\u200B"]
		| ["\u3000"]
	>
}

/* Section 7.3 : Line Terminators */

<DEFAULT, IN_REGEX>
SKIP: //SPECIAL_TOKEN :
{
	<LINE_TERMINATOR: <LF> | <CR> | <LS> | <PS> >
| 
	< #LF: "\n" > /* Line Feed */
| 
	< #CR: "\r" > /* Carriage Return */
| 
	< #LS: "\u2028" > /* Line separator */
| 
	< #PS: "\u2029" > /* Paragraph separator */
}


/* Comments */

<DEFAULT, IN_REGEX>
MORE :
{
	"//" : IN_SINGLE_LINE_COMMENT
|
	"/*" : IN_MULTI_LINE_COMMENT
//|
//	"/**" : IN_MULTI_LINE_DOC
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
	<SINGLE_LINE_COMMENT: (~["\n","\r"])* ("\n"|"\r"|"\r\n")? > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
	<MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

//<IN_MULTI_LINE_DOC>
//SPECIAL_TOKEN :
//{
//	<MULTI_LINE_DOC: "**/" > : DEFAULT
//}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT, IN_PATTERN>
MORE :
{
	< ~[] >
}



/* Section 7.5.1: Reserved Words */

<DEFAULT, IN_REGEX>
TOKEN :
{
 /************************** LARA TOKENS *************************************/
  <INCLUDE: "include">: DEFAULT
| 
	<ASPECTDEF: "aspectdef">: DEFAULT
| 
	<CODEDEF: "codedef">: DEFAULT
| 
	<INPUT: "input">: DEFAULT
| 
	<OUTPUT: "output">: DEFAULT
| 
	< STATICDECL: "static" > : DEFAULT 
| 
	<SELECT: "select" >: DEFAULT 
| 
	<APPLY: "apply">: DEFAULT 
|
	<TO: "to">: DEFAULT
| 
	<CALL: "call" >: DEFAULT
| 
	<RUN: "run" >: DEFAULT 
|
	<CMD: "cmd" >: DEFAULT 
| 
	<CONDITION: "condition" >: DEFAULT 
| 
	<BEGIN: "begin">: DEFAULT 
| 
	<INSERT: "insert">: DEFAULT
| 
	<EXEC: "exec">: DEFAULT
| 
	<OUTPUT_ACT: "out">: DEFAULT
| 
	<BEFORE: "before">: DEFAULT 
| 
	<AFTER: "after">: DEFAULT
|
	<AROUND: "around">: DEFAULT
|
	<REPLACE: "replace">: DEFAULT
| 
	<DEFINE: "def">: DEFAULT 
|
	<CHECK: "check" >: DEFAULT
| 
	<INITIALIZE: "initialize" >: DEFAULT
| 
	<FINALIZE: "finalize" >: DEFAULT
| 
	<END: "end"> : DEFAULT 
|
 /*******Tokens required for the dynamic apply ******/
	<DYNAMIC: "dynamic">: DEFAULT 
|
	<SEQUENCIAL: "seq">: DEFAULT 
|
	<PARALLEL: "par">: DEFAULT 
|
 /************************** LARA TOKENS *************************************/
	< BREAK: "break" > : DEFAULT
| 
	< CONTINUE: "continue" > : DEFAULT
| 
	< DELETE: "delete" > : DEFAULT
| 
	< ELSE: "else" > : DEFAULT
| 
	< FOR: "for" > : DEFAULT
| 
	< FUNCTION: "function" > : DEFAULT
| 
	< FUNCTION_GEN: "function*" > : DEFAULT	
| 
	< IF: "if" > : DEFAULT
| 
	< IN: "in" > : DEFAULT
| 
	< OF: "of" > : DEFAULT
| 
	< EACH: "each" > : DEFAULT
| 
	< NEW: "new" > : DEFAULT
| 
	< RETURN: "return" > : DEFAULT
| 
	< YIELD: "yield" > : DEFAULT	
| 
	< THIS: "this" > : IN_REGEX
| 
	< TYPEOF: "typeof" > : DEFAULT
| 
	< VAR: "var" > : DEFAULT
| 
	< VOID: "void" > : DEFAULT
| 
	< WHILE: "while" > : DEFAULT
| 
	< WITH: "with" > : DEFAULT
| 
	< CASE: "case" > : DEFAULT
| 
	< CATCH: "catch" > : DEFAULT
| 
	< CLASS: "class" > : DEFAULT
| 
	< CONST: "const" > : DEFAULT
| 
	< DEBUGGER: "debugger" > : DEFAULT
| 
	< _DEFAULT: "default" > : DEFAULT
| 
	< DO: "do" > : DEFAULT
| 
	< ENUM: "enum" > : DEFAULT
| 
	< EXTENDS: "extends" > : DEFAULT
| 
	< FINALLY: "finally" > : DEFAULT
| 
	< IMPORT: "import" > : DEFAULT
| 
	< SUPER: "super" > : DEFAULT
| 
	< SWITCH: "switch" > : DEFAULT
| 
	< THROW: "throw" > : DEFAULT
| 
	< TRY: "try" > : DEFAULT
//|
//	< UTF8_BOM: "\u00EF\u00BB\u00BF" > : DEFAULT
}



/* JScript .NET Tokens

TOKEN :
{
	< BYTE: "byte" >
	| < SBYTE: "sbyte" >
	| < SHORT: "short" >
	| < USHORT: "ushort" >
	| < UINT: "uint" >
	| < LONG: "long" >
	| < ULONG: "ulong" >
	| < FLOAT: "float" >
	| < NUMBER: "Number" >
	| < DOUBLE: "double" >
	| < DECIMAL: "decimal" >
	| < BOOLEAN: "boolean" >
	| < STRING: "String" >
	| < CHAR: "char" >
}

*/


/* Section 7.7: Punctuators */

<DEFAULT, IN_REGEX>
TOKEN :
{
	< LBRACE: "{" > : DEFAULT
|
	< RBRACE: "}" > : IN_REGEX
|
	< LPAREN: "(" > : DEFAULT
|
	< RPAREN: ")" > : IN_REGEX
|
	< LBRACKET: "[" > : DEFAULT
|
	< RBRACKET: "]" > : IN_REGEX
|
	< DOT: "." > : DEFAULT
|
	< SEMICOLON: ";" > : DEFAULT
|
	< COMMA: "," > : DEFAULT
|
	< LT: "<" > : DEFAULT
|
	< GT: ">" > : DEFAULT
|
	< LE: "<=" > : DEFAULT
|
	< GE: ">=" > : DEFAULT
|
	< EQ: "==" > : DEFAULT
|
	< NE: "!=" > : DEFAULT
|
	<MATCH:"~=" >: DEFAULT  /* LARA operator */
|
	< SEQ: "===" > : DEFAULT /* Strict Equals Operator */
|
	< SNEQ: "!==" >	 : DEFAULT /* Strict Does-not-equal Operator */
|
	< PLUS: "+" > : DEFAULT
|
	< MINUS: "-" > : DEFAULT
|
	< STAR: "*" > : DEFAULT
|
	< REM: "%" > : DEFAULT
|
	< INCR: "++" > : IN_REGEX
|
	< DECR: "--" > : IN_REGEX
|
	< LSHIFT: "<<" > : DEFAULT
|
	< RSHIFT: ">>" > : DEFAULT
|
	< RUNSHIFT: ">>>" > : DEFAULT /* Unsigned Right Shift Operator */
|
	< BIT_AND: "&" > : DEFAULT
|
	< BIT_OR: "|" > : DEFAULT
|
	< XOR: "^" > : DEFAULT
|
	< BANG: "!" > : DEFAULT
|
	< TILDE: "~" > : IN_REGEX
|
	< SC_AND: "&&" > : DEFAULT
|
	< SC_OR: "||" > : DEFAULT
|
	< HOOK: "?" > : DEFAULT
|
	< NATURAL_JOIN: "::" > : DEFAULT /* LARA Operator*/
|
	< COLON: ":" > : DEFAULT
| 
	< ASSIGN: "=" > : DEFAULT
|
	< PLUSASSIGN: "+=" > : DEFAULT
|
	< MINUSASSIGN: "-=" > : DEFAULT
|
	< STARASSIGN: "*=" > : DEFAULT
|
	< REMASSIGN: "%=" > : DEFAULT
|
	< LSHIFTASSIGN: "<<=" > : DEFAULT
|
	< RSIGNEDSHIFTASSIGN: ">>=" > : DEFAULT
|
	< RUNSIGNEDSHIFTASSIGN: ">>>=" > : DEFAULT
|
	< ANDASSIGN: "&=" > : DEFAULT
|
	< ORASSIGN: "|=" > : DEFAULT
|
	< XORASSIGN: "^=" > : DEFAULT
|
	< INTANCE_OF: "instanceof" > : DEFAULT
}


/* Section 7.8.3: Numeric Literals */

<DEFAULT, IN_REGEX>
TOKEN:
{ 
	< DECIMAL_LITERAL :
		<DECIMAL_INTEGER_LITERAL> "." (<DECIMAL_DIGITS>)? (<EXPONENT_PART>)?
	| 
		"." <DECIMAL_DIGITS> (<EXPONENT_PART>)?
	| 
		<DECIMAL_INTEGER_LITERAL> (<EXPONENT_PART>)? 
	>  : IN_REGEX
|  
	< #NON_ZERO_DIGIT: ["1"-"9"] >
|
	< #EXPONENT_PART: ("e" | "E") (["+","-"])? <DECIMAL_DIGITS> >
}

<DEFAULT, IN_REGEX>
TOKEN:
{
	< DECIMAL_INTEGER_LITERAL: 
		"0" | <NON_ZERO_DIGIT> (<DECIMAL_DIGITS>)?
	> : IN_REGEX
}

<DEFAULT, IN_REGEX>
TOKEN:
{
	< HEX_INTEGER_LITERAL: "0" ["x","X"] (<HEX_DIGIT>)+ > : IN_REGEX
}

<DEFAULT, IN_REGEX>
TOKEN:
{  < DECIMAL_DIGITS: (<DECIMAL_DIGIT>)+ > : IN_REGEX }

TOKEN:
{
	< DECIMAL_DIGIT: ["0"-"9"] >
}

/* Section 7.8.1: NULL Literals */

<DEFAULT, IN_REGEX>
TOKEN:
{ 
	< NULL_LITERAL: "null" > : IN_REGEX
}

/* Section 7.8.2: Boolean Literals */

<DEFAULT, IN_REGEX>
TOKEN:
{ 
	< BOOLEAN_LITERAL: "true" | "false" > : IN_REGEX
}



/* Section 7.8.4: String Literals */

<DEFAULT, IN_REGEX>
TOKEN:
{
	< STRING_LITERAL:
		"\"" (<DOUBLE_STRING_CHARACTERS>)? "\""  | "'" (<SINGLE_STRING_CHARACTERS>)? "'"
	>	 : IN_REGEX
|
	< #DOUBLE_STRING_CHARACTERS: (<DOUBLE_STRING_CHARACTER>)* >
|
	< #SINGLE_STRING_CHARACTERS: (<SINGLE_STRING_CHARACTER>)* >
|
	< #DOUBLE_STRING_CHARACTER:
		(~["\"","\\","\n","\r","\u2028","\u2029"])* 
		| "\\" <ESCAPE_SEQUENCE>
	>
|
	< #SINGLE_STRING_CHARACTER:
		(~["'","\\","\n","\r","\u2028","\u2029"]) 
		| "\\" <ESCAPE_SEQUENCE>
	> 
|
	< #ESCAPE_SEQUENCE:
		<CHARACTER_ESCAPE_SEQUENCE>
		| 
			"0" 
		| 
			<HEX_ESCAPE_SEQUENCE>
		| 
			<UNICODE_ESCAPE_SEQUENCE>
	>
|
	< #CHARACTER_ESCAPE_SEQUENCE:
		<SINGLE_ESCAPE_CHARACTER> | <NON_ESCAPE_CHARACTER>
	>
|
	< #SINGLE_ESCAPE_CHARACTER: ["'" , "\"" , "\\" , "b" , "f" , "n" , "r" , "t" , "v"] >
|
	< #NON_ESCAPE_CHARACTER: 
		~["\n","\r","\u2028","\u2029"]
	| 
		~["'" , "\"" , "\\" , "b" , "f" , "n" , "r" , "t" , "v", "x", "u"]
	| 
		~["0"-"9"]
	>
}

TOKEN:
{
	< HEX_ESCAPE_SEQUENCE: "x" <HEX_DIGIT> <HEX_DIGIT> >
}

< DEFAULT, IN_REGEX >
TOKEN:
{
	<CODE_LITERAL: "%{" (~["}"])* "}" ("}" | ~["}","%"] (~["}"])* "}")* "%">: DEFAULT
	
}

/*
TOKEN:
{
  < ESCAPE_CHARACTER:
	  ["'" , "\"" , "\\" , "b" , "f" , "n" , "r" , "t" , "v"]
	| ["0"-"9"]
	| "x"
	| "u"
  >
}
*/

/* Section 7.6: Identifiers */

<DEFAULT, IN_REGEX>
TOKEN:
{
	< LABEL_IDENTIFIER:
				"#"  (<IDENTIFIER_PART>)*
	> : IN_REGEX
| 
	< IDENTIFIER_NAME:
				( <DOLLAR_SIGN> (<DOLLAR_SIGN> | "*" | "#" | "^") )
			| 
				(( <DOLLAR_SIGN> | < AT_SIGN >)? <IDENTIFIER_START> (<IDENTIFIER_PART>)*)
	> : IN_REGEX
|
	< #IDENTIFIER_START:
		<UNICODE_LETTER>
	| 
		<UNDER_SCORE>
	| 
		<UNICODE_ESCAPE_SEQUENCE>
	>
|
	< #IDENTIFIER_PART: 
		<IDENTIFIER_START>
	| 
		<UNICODE_COMBINING_MARK>
	| 
		<UNICODE_DIGIT>
	| 
		<UNICODE_CONNECTOR_PUNCTUATION>
	| 
		<UNICODE_ESCAPE_SEQUENCE>
	|
		<DOLLAR_SIGN>
	>
|
	< #DOLLAR_SIGN: "$" >
|
	< #AT_SIGN: "@" >
|  
	< #UNDER_SCORE: "_" >
|
	< #UNICODE_LETTER: 
		["A"-"Z"]
		| ["a"-"z"]
		| ["\u0041"-"\u005A"] 
		| ["\u0061"-"\u007A"] 
		| ["\u00AA"] 
		| ["\u00B5"]
		| ["\u00BA"] 
		| ["\u00C0"-"\u00D6"] 
		| ["\u00D8"-"\u00F6"] 
		| ["\u00F8"-"\u021F"]
		| ["\u0222"-"\u0233"] 
		| ["\u0250"-"\u02AD"] 
		| ["\u02B0"-"\u02B8"] 
		| ["\u02BB"-"\u02C1"]
		| ["\u02D0"-"\u02D1"] 
		| ["\u02E0"-"\u02E4"] 
		| ["\u02EE"] 
		| ["\u037A"]
		| ["\u0386"] 
		| ["\u0388"-"\u038A"]
		| ["\u038C"]
		| ["\u038E"-"\u03A1"]
		| ["\u03A3"-"\u03CE"] 
		| ["\u03D0"-"\u03D7"] 
		| ["\u03DA"-"\u03F3"]
		| ["\u0400"-"\u0481"]
		| ["\u048C"-"\u04C4"]
		| ["\u04C7"-"\u04C8"]
		| ["\u04CB"-"\u04CC"] 
		| ["\u04D0"-"\u04F5"]
		| ["\u04F8"-"\u04F9"]
		| ["\u0531"-"\u0556"]
		| ["\u0559"]
		| ["\u0561"-"\u0587"]
		| ["\u05D0"-"\u05EA"]
		| ["\u05F0"-"\u05F2"] 
		| ["\u0621"-"\u063A"] 
		| ["\u0640"-"\u064A"]
		| ["\u0671"-"\u06D3"]
		| ["\u06D5"] 
		| ["\u06E5"-"\u06E6"] 
		| ["\u06FA"-"\u06FC"]
		| ["\u0710"] 
		| ["\u0712"-"\u072C"] 
		| ["\u0780"-"\u07A5"] 
		| ["\u0905"-"\u0939"]
		| ["\u093D"] 
		| ["\u0950"] 
		| ["\u0958"-"\u0961"] 
		| ["\u0985"-"\u098C"]
		| ["\u098F"-"\u0990"] 
		| ["\u0993"-"\u09A8"] 
		| ["\u09AA"-"\u09B0"] 
		| ["\u09B2"]
		| ["\u09B6"-"\u09B9"] 
		| ["\u09DC"-"\u09DD"] 
		| ["\u09DF"-"\u09E1"] 
		| ["\u09F0"-"\u09F1"]
		| ["\u0A05"-"\u0A0A"] 
		| ["\u0A0F"-"\u0A10"] 
		| ["\u0A13"-"\u0A28"] 
		| ["\u0A2A"-"\u0A30"]
		| ["\u0A32"-"\u0A33"] 
		| ["\u0A35"-"\u0A36"] 
		| ["\u0A38"-"\u0A39"] 
		| ["\u0A59"-"\u0A5C"]
		| ["\u0A5E"] 
		| ["\u0A72"-"\u0A74"] 
		| ["\u0A85"-"\u0A8B"] 
		| ["\u0A8D"]
		| ["\u0A8F"-"\u0A91"] 
		| ["\u0A93"-"\u0AA8"] 
		| ["\u0AAA"-"\u0AB0"] 
		| ["\u0AB2"-"\u0AB3"]
		| ["\u0AB5"-"\u0AB9"] 
		| ["\u0ABD"] 
		| ["\u0AD0"] 
		| ["\u0AE0"]
		| ["\u0B05"-"\u0B0C"] 
		| ["\u0B0F"-"\u0B10"] 
		| ["\u0B13"-"\u0B28"] 
		| ["\u0B2A"-"\u0B30"]
		| ["\u0B32"-"\u0B33"] 
		| ["\u0B36"-"\u0B39"] 
		| ["\u0B3D"] 
		| ["\u0B5C"-"\u0B5D"]
		| ["\u0B5F"-"\u0B61"] 
		| ["\u0B85"-"\u0B8A"]
		| ["\u0B8E"-"\u0B90"] 
		| ["\u0B92"-"\u0B95"]
		| ["\u0B99"-"\u0B9A"] 
		| ["\u0B9C"] 
		| ["\u0B9E"-"\u0B9F"] 
		| ["\u0BA3"-"\u0BA4"]
		| ["\u0BA8"-"\u0BAA"] 
		| ["\u0BAE"-"\u0BB5"] 
		| ["\u0BB7"-"\u0BB9"] 
		| ["\u0C05"-"\u0C0C"]
		| ["\u0C0E"-"\u0C10"] 
		| ["\u0C12"-"\u0C28"]
		| ["\u0C2A"-"\u0C33"]
		| ["\u0C35"-"\u0C39"]
		| ["\u0C60"-"\u0C61"]
		| ["\u0C85"-"\u0C8C"]
		| ["\u0C8E"-"\u0C90"]
		| ["\u0C92"-"\u0CA8"]
		| ["\u0CAA"-"\u0CB3"]
		| ["\u0CB5"-"\u0CB9"]
		| ["\u0CDE"]
		| ["\u0CE0"-"\u0CE1"]
		| ["\u0D05"-"\u0D0C"]
		| ["\u0D0E"-"\u0D10"]
		| ["\u0D12"-"\u0D28"]
		| ["\u0D2A"-"\u0D39"]
		| ["\u0D60"-"\u0D61"]
		| ["\u0D85"-"\u0D96"]
		| ["\u0D9A"-"\u0DB1"]
		| ["\u0DB3"-"\u0DBB"]
		| ["\u0DBD"]
		| ["\u0DC0"-"\u0DC6"]
		| ["\u0E01"-"\u0E30"]
		| ["\u0E32"-"\u0E33"]
		| ["\u0E40"-"\u0E46"]
		| ["\u0E81"-"\u0E82"]
		| ["\u0E84"]
		| ["\u0E87"-"\u0E88"]
		| ["\u0E8A"]
		| ["\u0E8D"]
		| ["\u0E94"-"\u0E97"]
		| ["\u0E99"-"\u0E9F"]
		| ["\u0EA1"-"\u0EA3"]
		| ["\u0EA5"]
		| ["\u0EA7"]
		| ["\u0EAA"-"\u0EAB"]
		| ["\u0EAD"-"\u0EB0"]
		| ["\u0EB2"-"\u0EB3"]
		| ["\u0EBD"-"\u0EC4"]
		| ["\u0EC6"]
		| ["\u0EDC"-"\u0EDD"]
		| ["\u0F00"]
		| ["\u0F40"-"\u0F6A"]
		| ["\u0F88"-"\u0F8B"]
		| ["\u1000"-"\u1021"]
		| ["\u1023"-"\u1027"]
		| ["\u1029"-"\u102A"]
		| ["\u1050"-"\u1055"]
		| ["\u10A0"-"\u10C5"]
		| ["\u10D0"-"\u10F6"]
		| ["\u1100"-"\u1159"]
		| ["\u115F"-"\u11A2"]
		| ["\u11A8"-"\u11F9"]
		| ["\u1200"-"\u1206"]
		| ["\u1208"-"\u1246"]
		| ["\u1248"]
		| ["\u124A"-"\u124D"]
		| ["\u1250"-"\u1256"]
		| ["\u1258"]
		| ["\u125A"-"\u125D"]
		| ["\u1260"-"\u1286"]
		| ["\u1288"]
		| ["\u128A"-"\u128D"]
		| ["\u1290"-"\u12AE"]
		| ["\u12B0"]
		| ["\u12B2"-"\u12B5"]
		| ["\u12B8"-"\u12BE"]
		| ["\u12C0"]
		| ["\u12C2"-"\u12C5"]
		| ["\u12C8"-"\u12CE"]
		| ["\u12D0"-"\u12D6"]
		| ["\u12D8"-"\u12EE"]
		| ["\u12F0"-"\u130E"]
		| ["\u1310"]
		| ["\u1312"-"\u1315"]
		| ["\u1318"-"\u131E"]
		| ["\u1320"-"\u1346"]
		| ["\u1348"-"\u135A"]
		| ["\u13A0"-"\u13B0"]
		| ["\u13B1"-"\u13F4"]
		| ["\u1401"-"\u1676"]
		| ["\u1681"-"\u169A"]
		| ["\u16A0"-"\u16EA"]
		| ["\u1780"-"\u17B3"]
		| ["\u1820"-"\u1877"]
		| ["\u1880"-"\u18A8"]
		| ["\u1E00"-"\u1E9B"]
		| ["\u1EA0"-"\u1EE0"]
		| ["\u1EE1"-"\u1EF9"]
		| ["\u1F00"-"\u1F15"]
		| ["\u1F18"-"\u1F1D"]
		| ["\u1F20"-"\u1F39"]
		| ["\u1F3A"-"\u1F45"]
		| ["\u1F48"-"\u1F4D"]
		| ["\u1F50"-"\u1F57"]
		| ["\u1F59"]
		| ["\u1F5B"]
		| ["\u1F5D"]
		| ["\u1F5F"-"\u1F7D"]
		| ["\u1F80"-"\u1FB4"]
		| ["\u1FB6"-"\u1FBC"]
		| ["\u1FBE"]
		| ["\u1FC2"-"\u1FC4"]
		| ["\u1FC6"-"\u1FCC"]
		| ["\u1FD0"-"\u1FD3"]
		| ["\u1FD6"-"\u1FDB"]
		| ["\u1FE0"-"\u1FEC"]
		| ["\u1FF2"-"\u1FF4"]
		| ["\u1FF6"-"\u1FFC"]
		| ["\u207F"]
		| ["\u2102"]
		| ["\u2107"]
		| ["\u210A"-"\u2113"]
		| ["\u2115"]
		| ["\u2119"-"\u211D"]
		| ["\u2124"]
		| ["\u2126"]
		| ["\u2128"]
		| ["\u212A"-"\u212D"]
		| ["\u212F"-"\u2131"]
		| ["\u2133"-"\u2139"]
		| ["\u2160"-"\u2183"]
		| ["\u3005"-"\u3007"]
		| ["\u3021"-"\u3029"]
		| ["\u3031"-"\u3035"]
		| ["\u3038"-"\u303A"]
		| ["\u3041"-"\u3094"]
		| ["\u309D"-"\u309E"]
		| ["\u30A1"-"\u30FA"]
		| ["\u30FC"-"\u30FE"]
		| ["\u3105"-"\u312C"]
		| ["\u3131"-"\u318E"]
		| ["\u31A0"-"\u31B7"]
		| ["\u3400"]
		| ["\u4DB5"]
		| ["\u4E00"]
		| ["\u9FA5"]
		| ["\uA000"-"\uA48C"]
		| ["\uAC00"]
		| ["\uD7A3"]
		| ["\uF900"-"\uFA2D"]
		| ["\uFB00"-"\uFB06"]
		| ["\uFB13"-"\uFB17"]
		| ["\uFB1D"]
		| ["\uFB1F"-"\uFB28"]
		| ["\uFB2A"-"\uFB36"]
		| ["\uFB38"-"\uFB3C"]
		| ["\uFB3E"]
		| ["\uFB40"-"\uFB41"]
		| ["\uFB43"-"\uFB44"]
		| ["\uFB46"-"\uFBB1"]
		| ["\uFBD3"-"\uFD3D"]
		| ["\uFD50"-"\uFD8F"]
		| ["\uFD92"-"\uFDC7"]
		| ["\uFDF0"-"\uFDFB"]
		| ["\uFE70"-"\uFE72"]
		| ["\uFE74"]
		| ["\uFE76"-"\uFEFC"]
		| ["\uFF21"-"\uFF3A"]
		| ["\uFF41"-"\uFF5A"]
		| ["\uFF66"-"\uFFBE"]
		| ["\uFFC2"-"\uFFC7"]
		| ["\uFFCA"-"\uFFCF"]
		| ["\uFFD2"-"\uFFD7"]
		| ["\uFFDA"-"\uFFDC"]
	>
} 

/*
 * Unicode categories Non-spacing mark (MN) OR Combining spacing mark (MC)
 */
MORE:
{
	< UNICODE_COMBINING_MARK: <MN> | <MC> >
}


TOKEN:
{
	< MC: 
		["\u0903"]
		| ["\u093E"]
		| ["\u093F"]
		| ["\u0940"]
		| ["\u0949"]
		| ["\u094A"]
		| ["\u094B"]
		| ["\u094C"]
		| ["\u0982"]
		| ["\u0983"]
		| ["\u09BE"]
		| ["\u09BF"]
		| ["\u09C0"]
		| ["\u09C7"]
		| ["\u09C8"]
		| ["\u09CB"]
		| ["\u09CC"]
		| ["\u09D7"]
		| ["\u0A03"]
		| ["\u0A3E"]
		| ["\u0A3F"]
		| ["\u0A40"]
		| ["\u0A83"]
		| ["\u0ABE"]
		| ["\u0ABF"]
		| ["\u0AC0"]
		| ["\u0AC9"]
		| ["\u0ACB"]
		| ["\u0ACC"]
		| ["\u0B02"]
		| ["\u0B03"]
		| ["\u0B3E"]
		| ["\u0B40"]
		| ["\u0B47"]
		| ["\u0B48"]
		| ["\u0B4B"]
		| ["\u0B4C"]
		| ["\u0B57"]
		| ["\u0BBE"]
		| ["\u0BBF"]
		| ["\u0BC1"]
		| ["\u0BC2"]
		| ["\u0BC6"]
		| ["\u0BC7"]
		| ["\u0BC8"]
		| ["\u0BCA"]
		| ["\u0BCB"]
		| ["\u0BCC"]
		| ["\u0BD7"]
		| ["\u0C01"]
		| ["\u0C02"]
		| ["\u0C03"]
		| ["\u0C41"]
		| ["\u0C42"]
		| ["\u0C43"]
		| ["\u0C44"]
		| ["\u0C82"]
		| ["\u0C83"]
		| ["\u0CBE"]
		| ["\u0CC0"]
		| ["\u0CC1"]
		| ["\u0CC2"]
		| ["\u0CC3"]
		| ["\u0CC4"]
		| ["\u0CC7"]
		| ["\u0CC8"]
		| ["\u0CCA"]
		| ["\u0CCB"]
		| ["\u0CD5"]
		| ["\u0CD6"]
		| ["\u0D02"]
		| ["\u0D03"]
		| ["\u0D3E"]
		| ["\u0D3F"]
		| ["\u0D40"]
		| ["\u0D46"]
		| ["\u0D47"]
		| ["\u0D48"]
		| ["\u0D4A"]
		| ["\u0D4B"]
		| ["\u0D4C"]
		| ["\u0D57"]
		| ["\u0D82"]
		| ["\u0D83"]
		| ["\u0DCF"]
		| ["\u0DD0"]
		| ["\u0DD1"]
		| ["\u0DD8"]
		| ["\u0DD9"]
		| ["\u0DDA"]
		| ["\u0DDB"]
		| ["\u0DDC"]
		| ["\u0DDD"]
		| ["\u0DDE"]
		| ["\u0DDF"]
		| ["\u0DF2"]
		| ["\u0DF3"]
		| ["\u0F3E"]
		| ["\u0F3F"]
		| ["\u0F7F"]
		| ["\u102C"]
		| ["\u1031"]
		| ["\u1038"]
		| ["\u1056"]
		| ["\u1057"]
		| ["\u17B6"]
		| ["\u17BE"]
		| ["\u17BF"]
		| ["\u17C0"]
		| ["\u17C1"]
		| ["\u17C2"]
		| ["\u17C3"]
		| ["\u17C4"]
		| ["\u17C5"]
		| ["\u17C7"]
		| ["\u17C8"]
		| ["\u1923"]
		| ["\u1924"]
		| ["\u1925"]
		| ["\u1926"]
		| ["\u1929"]
		| ["\u192A"]
		| ["\u192B"]
		| ["\u1930"]
		| ["\u1931"]
		| ["\u1933"]
		| ["\u1934"]
		| ["\u1935"]
		| ["\u1936"]
		| ["\u1937"]
		| ["\u1938"]
		| ["\u19B0"]
		| ["\u19B1"]
		| ["\u19B2"]
		| ["\u19B3"]
		| ["\u19B4"]
		| ["\u19B5"]
		| ["\u19B6"]
		| ["\u19B7"]
		| ["\u19B8"]
		| ["\u19B9"]
		| ["\u19BA"]
		| ["\u19BB"]
		| ["\u19BC"]
		| ["\u19BD"]
		| ["\u19BE"]
		| ["\u19BF"]
		| ["\u19C0"]
		| ["\u19C8"]
		| ["\u19C9"]
		| ["\u1A19"]
		| ["\u1A1A"]
		| ["\u1A1B"]
		| ["\uA802"]
		| ["\uA823"]
		| ["\uA824"]
		| ["\uA827"]
		| ["\u1D16"]
		| ["\u1D16"]
		| ["\u1D16"]
		| ["\u1D16"]
		| ["\u1D16"]
		| ["\u1D17"]
		| ["\u1D17"]
		| ["\u1D17"] 
	>
|
	< MN: 
		["\u0300"-"\u034E"] 
		| ["\u0360"-"\u0362"] 
		| ["\u0483"-"\u0486"] 
		| ["\u0591"-"\u05A1"]
		| ["\u05A3"-"\u05B9"] 
		| ["\u05BB"-"\u05BD"] 
		| ["\u05BF"]
		| ["\u05C1"-"\u05C2"]
		| ["\u05C4"]
		| ["\u064B"-"\u0655"] 
		| ["\u0670"]
		| ["\u06D6"-"\u06DC"]
		| ["\u06DF"-"\u06E4"] 
		| ["\u06E7"-"\u06E8"] 
		| ["\u06EA"-"\u06ED"] 
		| ["\u0711"]
		| ["\u0730"-"\u074A"] 
		| ["\u07A6"-"\u07B0"] 
		| ["\u0901"-"\u0903"] 
		| ["\u093C"]
		| ["\u093E"-"\u094D"] 
		| ["\u0951"-"\u0954"] 
		| ["\u0962"-"\u0963"] 
		| ["\u0981"-"\u0983"]
		| ["\u09BC"-"\u09C4"] 
		| ["\u09C7"-"\u09C8"] 
		| ["\u09CB"-"\u09CD"] 
		| ["\u09D7"]
		| ["\u09E2"-"\u09E3"] 
		| ["\u0A02"]
		| ["\u0A3C"]
		| ["\u0A3E"-"\u0A42"]
		| ["\u0A47"-"\u0A48"] 
		| ["\u0A4B"-"\u0A4D"] 
		| ["\u0A70"-"\u0A71"] 
		| ["\u0A81"-"\u0A83"]
		| ["\u0ABC"]
		| ["\u0ABE"-"\u0AC5"] 
		| ["\u0AC7"-"\u0AC9"] 
		| ["\u0ACB"-"\u0ACD"]
		| ["\u0B01"-"\u0B03"] 
		| ["\u0B3C"]
		| ["\u0B3E"-"\u0B43"] 
		| ["\u0B47"-"\u0B48"]
		| ["\u0B4B"-"\u0B4D"] 
		| ["\u0B56"-"\u0B57"] 
		| ["\u0B82"-"\u0B83"] 
		| ["\u0BBE"-"\u0BC2"]
		| ["\u0BC6"-"\u0BC8"] 
		| ["\u0BCA"-"\u0BCD"] 
		| ["\u0BD7"]
		| ["\u0C01"-"\u0C03"]
		| ["\u0C3E"-"\u0C44"] 
		| ["\u0C46"-"\u0C48"] 
		| ["\u0C4A"-"\u0C4D"] 
		| ["\u0C55"-"\u0C56"]
		| ["\u0C82"-"\u0C83"] 
		| ["\u0CBE"-"\u0CC4"] 
		| ["\u0CC6"-"\u0CC8"] 
		| ["\u0CCA"-"\u0CCD"]
		| ["\u0CD5"-"\u0CD6"] 
		| ["\u0D02"-"\u0D03"] 
		| ["\u0D3E"-"\u0D43"] 
		| ["\u0D46"-"\u0D48"]
		| ["\u0D4A"-"\u0D4D"] 
		| ["\u0D57"]
		| ["\u0D82"-"\u0D83"] 
		| ["\u0DCA"]
		| ["\u0DCF"-"\u0DD4"] 
		| ["\u0DD6"]
		| ["\u0DD8"-"\u0DDF"] 
		| ["\u0DF2"-"\u0DF3"]
		| ["\u0E31"]
		| ["\u0E34"-"\u0E3A"] 
		| ["\u0E47"-"\u0E4E"] 
		| ["\u0EB1"]
		| ["\u0EB4"-"\u0EB9"] 
		| ["\u0EBB"-"\u0EBC"] 
		| ["\u0EC8"-"\u0ECD"] 
		| ["\u0F18"-"\u0F19"]
		| ["\u0F35"]
		| ["\u0F37"]
		| ["\u0F39"]
		| ["\u0F3E"-"\u0F3F"]
		| ["\u0F71"-"\u0F84"] 
		| ["\u0F86"-"\u0F87"] 
		| ["\u0F90"-"\u0F97"] 
		| ["\u0F99"-"\u0FBC"]
		| ["\u0FC6"]
		| ["\u102C"-"\u1032"] 
		| ["\u1036"-"\u1039"] 
		| ["\u1056"-"\u1059"]
		| ["\u17B4"-"\u17D3"] 
		| ["\u18A9"]
		| ["\u20D0"-"\u20DC"] 
		| ["\u20E1"]
		| ["\u302A"-"\u302F"] 
		| ["\u3099"-"\u309A"] 
		| ["\uFB1E"]
		| ["\uFE20"-"\uFE23"]
	>
}

TOKEN:
{
	< UNICODE_DIGIT: 
		["\u0030"-"\u0039"] 
		| ["\u0660"-"\u0669"] 
		| ["\u06F0"-"\u06F9"] 
		| ["\u0966"-"\u096F"]
		| ["\u09E6"-"\u09EF"] 
		| ["\u0A66"-"\u0A6F"] 
		| ["\u0AE6"-"\u0AEF"] 
		| ["\u0B66"-"\u0B6F"]
		| ["\u0BE7"-"\u0BEF"] 
		| ["\u0C66"-"\u0C6F"] 
		| ["\u0CE6"-"\u0CEF"] 
		| ["\u0D66"-"\u0D6F"]
		| ["\u0E50"-"\u0E59"] 
		| ["\u0ED0"-"\u0ED9"] 
		| ["\u0F20"-"\u0F29"] 
		| ["\u1040"-"\u1049"]
		| ["\u1369"-"\u1371"] 
		| ["\u17E0"-"\u17E9"] 
		| ["\u1810"-"\u1819"] 
		| ["\uFF10"-"\uFF19"] 
  >
}

TOKEN:
{
	< UNICODE_CONNECTOR_PUNCTUATION: 
		["\u005F"] 
	| 
		["\u203F"-"\u2040"]
	| 
		["\u30FB"] 
	| 
		["\uFE33"-"\uFE34"]
	| 
		["\uFE4D"-"\uFE4F"]
	| 
		["\uFF3F"]
	| 
		["\uFF65"]
	>
}

TOKEN:
{
	< UNICODE_ESCAPE_SEQUENCE: "u" <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT> <HEX_DIGIT> >
}

TOKEN:
{
	< HEX_DIGIT: ["0"-"9"] | ["a"-"f"] | ["A"-"F"] >
}



<IN_REGEX>
TOKEN :
{
	< SLASHASSIGN: "/=" > : DEFAULT
|
	< SLASH: "/" > : DEFAULT
}

 /* ************************* LARA TOKENS *************************************
<DEFAULT, IN_REGEX>
TOKEN : /* JP IDENTIFIERS *
{
  < JPVAR: "$" (<IDENTIFIER_NAME> | <IN_JPVAR>)>  :DEFAULT |
  < #IN_JPVAR: <CALL > | <BEGIN > | < END > | <FUNCTION > | <VAR> | <RETURN> | <IF> | <ELSE> >
}
 /* ************************* LARA TOKENS ************************************* /

/* Section 7.8.5: Regular Expression Literals */

<DEFAULT>
TOKEN :
{
	< REGULAR_EXPRESSION_LITERAL:
		"/" ( (~["\n","\r","\\","/","*"]) | <BACKSLASH_SEQUENCE> ) 
		( (~["\n","\r","\\","/"]) | <BACKSLASH_SEQUENCE> )* "/" (<IDENTIFIER_PART>)*
	> : IN_REGEX
|
	< #BACKSLASH_SEQUENCE:
		"\\" (~["\n","\r"])
	>
}


/** Function that returns the join point identifier, which can be any identifier
	or one of the following reserved words
	 **/
	Token getNoReservedIdentifier() :
	{Token t;}
	{
	  (
	    t= <IDENTIFIER_NAME> |
	    t=<CALL > | t=<BEGIN > | t=< END > |
	    t=<FUNCTION > | t=<FUNCTION_GEN > | t=<VAR> | t=<RETURN> | t=<YIELD> |
	    t=<IF> | t=<ELSE> | t=<TO> | t=<IN> | t=< SWITCH > | t=< CASE > |
	    t=<INPUT> | t=<OUTPUT> | t=<CONDITION>  | t=<_DEFAULT> |  t=<CLASS> | t=< INTANCE_OF > |
	    t=<BEFORE> |  t=<AFTER> | t=<AROUND> |
	  	t=<FOR> | t=<WHILE> |t=<DO> | t=<INCLUDE> //|t=< REPLACE >
	  )
	  {return t;}
	}



	void noReservedIdentifier() #Identifier:
	{Token t;}
	{
	  (
	    t= <IDENTIFIER_NAME> |
	    t=<CALL > | t=<BEGIN > | t=< END > |
	    t=<FUNCTION > | t=<FUNCTION_GEN > | t=<VAR> | t=<RETURN> | t=<YIELD> |
	    t=<IF> | t=<ELSE> | t=<TO> | t=<IN> | t=< SWITCH > | t=< CASE > |
	    t=<INPUT> | t=<OUTPUT> | t=<CONDITION> | t=<_DEFAULT> | t=< CLASS > | t=< INTANCE_OF > |
	    t=<BEFORE> |  t=<AFTER> | t=<AROUND> |
	  	t=<FOR> | t=<WHILE> |t=<DO> | t=<INCLUDE> //|t=< REPLACE >
	  )
	  { jjtThis.jjtSetValue(t.image);
	   //jjtThis.setCoord(t,t);
	   }
	}

/*****************************************
 * ECMA SYNTACTIC GRAMMARS  STARTS HERE  *
 *****************************************/

/*******************************************************************************
 ************************    LARA SYNTACTIC GRAMMAR    ************************* 
 *******************************************************************************/

	/**
     * A LARA file can contain zero or more includes and imports, followed by definitions of aspectdefs,
     * codedefs, functions and global variables
     **/
	ASTStart Start() #Start:
	{} 
	{
//	    [<UTF8_BOM>]
	  	(Import())* 
	    (AspectDef()
	  		| CodeDef()
	  		| Declaration()
	     )*
		<EOF>
		{ return jjtThis; }
	}

	void Declaration() #void: { }
	{

		  LOOKAHEAD((<FUNCTION_GEN > )  Identifier()) GeneratorFunctionDeclaration()
	 	| LOOKAHEAD((<FUNCTION > )  Identifier()) FunctionDeclaration() 	 
	  	| VariableStatement()
	  	| 
		(
		  
		LeftHandSideExpression() AssignmentOperator() AssignmentExpression() [<SEMICOLON >]
		)#AssignmentExpression
	}
	
	/**
     * The path to a file that is not in the same path of the invoked LARA file. With one import it is
     * possible to import one or every file within a package
     **/
	void Import() #Import:
	{Token t; Token begin; Token end;}
	{
	  begin=<IMPORT> t=FilePath() end=EndStatement()
	  {jjtThis.jjtSetValue(t.image);}
	 // { jjtThis.setCoord(begin,end);}
	}
	/** FilePath
	* gets the path to a file or all the files in the package 
	**/
	Token FilePath():
	{Token t;}
	{
	  (LOOKAHEAD(2)Identifier()<DOT>)* (t=<IDENTIFIER_NAME> |t=<STAR >)
		{return t;}
	}

	/** FilePathNoSTar
	* gets the path to a file in a package
	**/
	void FilePathNoSTar() #FilePath:
	{}
	{
	  (LOOKAHEAD(2)Identifier()<DOT>)+
	}	
	
	 /**
     * Code Definition A parcel of native code or LARA-Code to be used by the insert/output action. To define the target
     * language, one has to define the type of the codedef, such as: codedef<C>, this means that the code to be inserted
     * is written in C language. A code definition needs an identifier and its body is code that can contain a tag such
     * as "<a>" to insert information on the code such as: join point property or a variable value. To use those tags,
     * the codedef must have input arguments to refer those to specific values.
     **/
	void CodeDef() #CodeDef:
	{Token name, code, language, begin, end;}
	{
	  {
	    setNamed(jjtThis, "language", "native");
	    //jjtThis.setLanguage("native");
	    } 
	  begin=<CODEDEF >[ <LT> language=<IDENTIFIER_NAME> <GT> {
		setNamed(jjtThis, "language", language.image);
	    //jjtThis.setLanguage(language.image);
	    }]
	  			name=<IDENTIFIER_NAME> {jjtThis.jjtSetValue(name.image);}
	  		( [<LPAREN> [FormalParameterList()] <RPAREN>] )#FormalParameterList(>0)
		code =<CODE_LITERAL>
	  	 {
			set(jjtThis, code);
	    	//String simpleCode = code.image.substring(2,code.image.length()-2);
	  		//jjtThis.setCode(simpleCode);
	 	 }
	  end=<END >

	 // { jjtThis.setCoord(begin,end);}
	}
	
	/**
     * Input arguments The arguments to be defined when a "aspect-call" action is stated. They can be normal variables
     * or variables referent to a specific join point. The normal variables can have a default value
     **/
	void Input() #Input: { Token begin, end;}
	{
		begin=<INPUT>
			VariableDeclarationList() (<SEMICOLON>)?
		end=<END>
		//{ jjtThis.setCoord(begin,end);}
	}

	/**
     * Output arguments List of normal variables or variables referent to a specific join point. The normal variables
     * can have a default value
     **/
	void Output() #Output: { Token begin, end;}
	{
	  	begin=<OUTPUT>
	  		VariableDeclarationList() (<SEMICOLON>)?
		end=<END> 
	}

	 /**
     * Static List of static variables and functions, which can be accessed statically in the aspect. The variables
     * values are shared between all aspect instances
     **/
	void Static() #Static: {}
	{
	  <STATICDECL>
	  	(VariableStatement()| GeneratorFunctionDeclaration() | FunctionDeclaration())*
	  <END>
	}

	/** Initialize
	 * Similar to a constructor. A block of JavaScript code to initialize variables, inter alia
	 **/
	void Initialize() #Initialize: {}
	{
	  <INITIALIZE>
	  	JavaScript()
	  <END>
	}
	/** Finalize
	 * Similar to a destructor. A block of JavaScript code to finalize output variables, inter alia
	 **/
	void Finalize() #Finalize: {}
	{
	  <FINALIZE>
	  	JavaScript()
	  <END>
	}
	
	/** Check
	 * Set of conditions to verify input arguments and other important stats that specify if the aspect can be executed
	 **/
	void Check() #Check: {}
	{
	  <CHECK>
	  	LogicalORExpression() [EndStatement() (LogicalORExpression() EndStatement())*]
	  <END>
	}
	
	/** Aspect Definition
	 * The aspect definition can contain outputs and inputs variables, a check to verify those variables, an initializer and a finalizer to deal with information to be handler before and after the aspect, respectively.
	 * The body of the aspect consists of selects, applies and conditions to apply the aspect in the target program, and afters, befores, function and variable declaration to assist the apply and condition section.
	 */
	void AspectDef() #AspectDef:
	{Token aspName, begin, end;}
	{
	  begin=<ASPECTDEF> 
		  aspName=<IDENTIFIER_NAME >
		  (
		      Input()
		    |
		      Output()
		    |
		      Static()
		  )*
		  
		  [ Initialize() ]
		  [ Check() ]
		  (
		    (
		      LOOKAHEAD([Identifier() <COLON>] <SELECT> ) Select()
			|
			  LOOKAHEAD([Identifier() <COLON>] <APPLY> | <APPLY>) Apply()
			|
			  LOOKAHEAD([Identifier() <COLON>] (< BEFORE>|<AFTER>) | (< BEFORE>|<AFTER>) ) AroundApply()
			| 
			  LOOKAHEAD([Identifier() <COLON>] < CONDITION>) Condition()
			| 
			  SourceElement()
		    )
		  )*
		  [ Finalize() ]
	  end=<END >
	  {jjtThis.jjtSetValue(aspName.image);}
	 // { jjtThis.setCoord(begin,end);}
	}

	/** Select
	 * Pointcut expression to specify which join points are intended to influence.
	 * It can contain an unique label, so it can be advised, and a pointcut expression
	 */
	void Select() #Select:
	{Token name, begin, end;}
	{
	  [name=<IDENTIFIER_NAME> {jjtThis.jjtSetValue(name.image); }<COLON>] begin=<SELECT> (
	      LOOKAHEAD((getNoReservedIdentifier()(<LBRACE>|<DOT>|<END>))
	      		|   ([<LPAREN>]getNoReservedIdentifier() <ASSIGN >)) Pointcut() |
	    
	      LOOKAHEAD(2) FourthSetOp()) end=< END >
	  //{ jjtThis.setCoord(begin,end);}
	}
	
	void FourthSetOp() #Join(>1):
	{Token joinType;}
	{
		ThirdSetOp() [LOOKAHEAD(2)joinType=<PLUS>FourthSetOp()
		{jjtThis.jjtSetValue(joinType.image);}]
	}

	void ThirdSetOp() #Join(>1):
	{Token joinType;}
	{
		FirstSetOp() [(joinType=<NATURAL_JOIN>|joinType=<BIT_AND>) ThirdSetOp()
		{jjtThis.jjtSetValue(joinType.image);}]
	}

	void FirstSetOp():{}
	{
		Identifier() | (<LPAREN> FourthSetOp()<RPAREN>)
	}	
	
	/** Pointcut
	 * It can contain an identifier for the join point, a join point identifier and a possible property expression. 
	 * Each join point can have a child, the join point down to its hierarchy
	 */	
	void Pointcut()#Pointcut:
	{Token joinPoint,reference;String referenceStr;}
	{
	  (
		<LPAREN> //e.g.: ($l1=loop){...}
				
	  	  reference = < IDENTIFIER_NAME> <ASSIGN>
	  	  joinPoint = getNoReservedIdentifier()
      	  {referenceStr = reference.image;}
	  	<RPAREN>
	  |
		LOOKAHEAD(< IDENTIFIER_NAME > <ASSIGN >) //e.g.: $l1=loop{...}
		  reference = < IDENTIFIER_NAME> <ASSIGN>
	  	  joinPoint = getNoReservedIdentifier()
      	  {referenceStr = reference.image;}
	  | 
	      joinPoint = getNoReservedIdentifier() ////e.g.: loop{...}
	      {referenceStr = "$"+joinPoint.image;}
	      
	  )
	  {
		set(jjtThis, joinPoint);
	    //jjtThis.jjtSetValue(joinPoint.image);
		setNamed(jjtThis, "reference", referenceStr);
	  	//jjtThis.setReference(referenceStr);
	  }
	
	  [PointcutFilters()]
	  [<DOT> Pointcut()]
	}
	
	/** Pointcut  properties
	 * The properties of a pointcut can be declared in three different ways:
		- it can be any property (*)
		- a set of properties that will be mapped to the default attribute
		- a property expression
	 */
	void PointcutFilters():
	{}
	{
	   <LBRACE> 
	   (<STAR>|
	   	 (LOOKAHEAD(<IDENTIFIER_NAME > (EqualityOperator()|RelationalOperator()) | <LPAREN> )
			(
			  	OrFiltersExpr()
				{
				  setNamed(jjtThis, "fullSpecified", true);
				  //jjtThis.setFullSpecified(true);
				  }
	        )
		   |
	   	    (
	
	   		  	 ( ConditionalExpression()
	   		  	 		(<COMMA> ConditionalExpression())*
	   		  	  ) #OrFiltersExpr(>1)
	   		  	  {
					setNamed(jjtThis, "fullSpecified", false);
	   		  	    //jjtThis.setFullSpecified(false);
	   		  	    }
	   		 )
	   	  )
	    #PointcutFilters
	   )
	   <RBRACE>     
	}
	
	/** "OR" Property Expr
	 * In the pointcut properties declaration, the comma is used as an OR operator (similar to ||)
	 **/
	void OrFiltersExpr() :{}
	{
	  (ANDFiltersExpr() (<COMMA > ANDFiltersExpr() )*) #OrFiltersExpr(>1)
	}
	
	/** "AND" Property Expression
	 * To combine properties such as an AND operation, the properties are declared inside brackets, converting the comma (which is the OR operator) into an AND.
	 */
	void ANDFiltersExpr():{}
	{
	   Filter() | <LPAREN> (Filter() (<COMMA > Filter() )*) #ANDFiltersExpr(>1) <RPAREN>
	}
	
	/** Property
	 * The property is defined by comparing a join point attribute to a value
	 **/
	void Filter() #Filter:
	{Token prop,op;}
	{
	   prop=<IDENTIFIER_NAME>  (EqualityOperator()|RelationalOperator()) ConditionalExpression()
	   {
	     set(jjtThis, prop);
	     //jjtThis.setProp(prop.image);
	   }
	}

	
	/** Around
	 * A Statement to occur around an apply
	 * It contains a list of applies that this statement refers to. The body of this statement is JavaScript, and can be used to prepare information for the applies.
	 **/
	void AroundApply() #AroundApply:
	{Token name,when, end;
	 String label = "";}
	{
	  [name=<IDENTIFIER_NAME> <COLON>{label = name.image;}]  ( when=<BEFORE> | when=<AFTER> )
	   		[(Identifier() ((LOOKAHEAD(2)<COMMA> Identifier())*))#Applies ]  <DO>
	  			JavaScript()
	  			
	  		{
				set(jjtThis, when);
				setNamed(jjtThis, "label", label);
	  		//  jjtThis.setName(label);
	  		//jjtThis.setWhen(when.image);
	  		} 
	  end=<END>
	//{ jjtThis.setCoord(when,end);}
	  
	}	
	
	/** Apply
	 * Old Version of apply, only static weaving
	 * Advice each join point of the related select(s).
	 * It can contain an unique label and a list of selects to be advised by the apply. If no select is inserted, the last select with no label will be used.
	 * The body contains JavaScript, in which the actions can be declared
	 **
	void Apply() #Apply:
	{Token name, apply, end;}
	{
	  [name=<IDENTIFIER_NAME>{jjtThis.setName(name.image);} <COLON>] apply=<APPLY> [To()]
	  		JavaScript()
	  end=<END>
	  { jjtThis.setCoord(apply,end);}
	}
	/**/

	/** Apply (Static/Dynamic)
	 * The new version of the Apply statement: static or dynamic weaving
	 * Advice each join point of the related select(s).
	 * It can contain an unique label and a list of selects to be advised by the apply. If no select is inserted, the last select with no label will be used.
	 * The body contains JavaScript, in which the actions can be declared
	 **/
	void Apply() #Apply:
	{Token name, apply, end;}
	{
	  [name=<IDENTIFIER_NAME>{
		set(jjtThis, name);
	    //jjtThis.jjtSetValue(name.image);
	    } <COLON>]
	  apply=<APPLY>
        
         [
         	< DYNAMIC > {
				setNamed(jjtThis, "dynamic", true);
         	  //jjtThis.setDynamic(true);
         	  }
	  		[
	  		    < PARALLEL >  {
	  		      setNamed(jjtThis, "concurrent", true);
	  		      //jjtThis.setConcurrent(true);
	  		      }
	  		  |
	  		    < SEQUENCIAL > {
	  		      	setNamed(jjtThis, "concurrent", false);
	  		      	//jjtThis.setConcurrent(false);
	  		      }
	  		]
	  		[ 
	  		    < BEFORE >  {
	  		      setNamed(jjtThis, "trigger", "before");
	  		      //jjtThis.setTrigger("before");
	  		      }
	  		  |
	  		    < AFTER > {
	  		      setNamed(jjtThis, "trigger", "after");
	  		      //jjtThis.setTrigger("after");
	  		      }
//	  		  |
//				//This needs to be fixed as it conflicts with the action "replace"	  		   	 
//	  		  	< REPLACE > {jjtThis.setTrigger("around");}
	  	    ]
         ]
	  
	  
	   [To()]
  	  JavaScript()
      end=<END>
      //{ jjtThis.setCoord(apply,end);}
	  
	  
	}
	
	/** To
	 * list of selects that will be influenced by the apply
	 **/
	void To() #To:
	{}
	{
	  <TO> FourthSetOp()
	  			(LOOKAHEAD(<COMMA> FourthSetOp()) <COMMA> FourthSetOp())* 
	}

	
	void SimpleAction() #Action:
	{Token t;}
	{
	    (
		    Insert()
		  |
		    Define()
		  |
		    Perform()
		  |
		    OutputAct() /**/
		)
		 EndStatement() 

	}

	/** Action
	 * Actions that can be used to influence the join points.
	 * A join point variable can be used to specify the targeted join point where the action takes place 
	 **/
	void Action() #void:
	{
	  Token t;
	}
	{
//
//	  LOOKAHEAD(LeftHandSideExpression() AssignmentOperator() ) (
//	    LeftHandSideExpression() AssignmentOperator()
//	    ActionOnAssign() 
//	   
//	  )#AssignmentExpression
//	| 
	  (	    
		(
		  	  (
		  	    (  
					  t=<IDENTIFIER_NAME>
					  {
					    jjtThis.jjtSetValue(t.image);
					    //jjtThis.setCoord(t,t);
					  }
				)#Identifier
			  )

			  (LOOKAHEAD(MemberExpressionPart())MemberExpressionPart())*
			  < DOT >
			
         )#CompositeReference(>1)
		(
		  Insert() |
		  Define() |
		  Perform() |
		  OutputAct()
		)
	   )#Action
		  EndStatement() 
	}


void ActionOnAssign() #Action:
	{
	  Token t;
	}
	{

		(		  (
		  	  (
		  	    (  
					  t=<IDENTIFIER_NAME>
					  {
					    jjtThis.jjtSetValue(t.image);
					    //jjtThis.setCoord(t,t);
					  }
				)#Identifier
			  )

			  (LOOKAHEAD(MemberExpressionPart())MemberExpressionPart())*
			  < DOT >
			
         )#CompositeReference(>1))?

		 
		 ExecOnAssign()
	}
	
	/** Call
	 * Action to invoke an aspect.
	 * The aspect is called with the input arguments that requires and the call instance can have a reference variable to be used to recover information from the invoked aspect.
	 **/
	void Call() #Call:
	{Token aspVarName,aspName,ref, end;}
	{
	  (	    
	   <CALL> [LOOKAHEAD(LeftHandSideExpression() <COLON>)
	   					LeftHandSideExpression() <COLON>]
   			 
	 |
	 	< VAR >  Identifier() < ASSIGN >  <CALL>
     |
        LeftHandSideExpression() < ASSIGN > <CALL >
	 )

	  [LOOKAHEAD(2)FilePathNoSTar()]
   			  	aspName=<IDENTIFIER_NAME>
					
	    	[Arguments()] end=EndStatement()
	 	
	   {
	     set(jjtThis, aspName);
		 //jjtThis.setAspName(aspName.image);
	    // jjtThis.setCoord(aspName,end);
	   }
	}

	

	/** Run
	 * Execution of an external tool.
	 **/
	void Run() #Run:
	{Token run, toolName, end;}
	{
	   run=<RUN> [LOOKAHEAD(LeftHandSideExpression() <COLON>)LeftHandSideExpression() <COLON>]
		  [toolName=getNoReservedIdentifier() {
			set(jjtThis, toolName);
		    //jjtThis.setToolName(toolName.image);
		    }]
		  	Arguments()
				[<GT> AssignmentExpression()]
	   end=EndStatement() 
	   		
	    // {jjtThis.setCoord(run,end);}
	}

	/** Command
	 * Execution of a command.
	 **/
	void Cmd() #Cmd:
	{Token cmd, toolName, end;}
	{
	(
	  cmd=<CMD> | cmd=<RUN> <CMD> {
		setNamed(jjtThis, "newVersion", true);
	    //jjtThis.setNewVersion(true);
	    }   )
	   [LOOKAHEAD(LeftHandSideExpression() <COLON>)LeftHandSideExpression() <COLON>]
	   	  	Arguments()
				[<GT> AssignmentExpression()]
	   end=EndStatement() 		
	     //{jjtThis.setCoord(cmd,end);}
	}

	/** OLD CALL **
	void Call() #Call:
	{Token aspVarName,aspName,ref, end;}
	{
	   <CALL> [LOOKAHEAD(<IDENTIFIER_NAME> <COLON>)
	   					aspVarName=<IDENTIFIER_NAME><COLON>
	   							{jjtThis.setAspVarName(aspVarName.image);}]
   			  [LOOKAHEAD(2)FilePathNoSTar()]aspName=<IDENTIFIER_NAME>
		{jjtThis.setAspName(aspName.image);}
	    	[LOOKAHEAD(Arguments())Arguments()] end=<SEMICOLON>
	  // { jjtThis.setCoord(aspName,end);}
	}
	/***/
	
	/** Insert
	 * The insertion of code is made by indicating a codedefinition's identifier with the required arguments or writing the desired code, with the possibility of using LARA-code to be defined into the target language, such as insert<C> before %{ï¿½}%.
	 * It is also needed to say if the code is inserted before, after or around the pointcut.
	 **/
	void Insert() #Insert:
	{Token when,language, begin, end;}
	{
	  {
	    setNamed(jjtThis, "language", "native");
	   //jjtThis.setLanguage("native");
	  }
	   (
	     (
	       begin=<INSERT>
			   (
			     (
			     [<LT> language=<IDENTIFIER_NAME> <GT>{
					setNamed(jjtThis, "language", language.image);
			       //jjtThis.setLanguage(language.image);
			       }]
			   		(when=<BEFORE> | when=<AFTER> | when=<AROUND> | when=<REPLACE>)
			   			ConditionalExpression()
//			   			(
//			   			  	TemplateLiteral()
//			   			|
//			   				((Identifier() [LOOKAHEAD(Arguments())Arguments()]) #CompositeReference(>1))
//			   			)
			   		{
					  setNamed(jjtThis, "when", when);
			   		  //jjtThis.setWhen(when.image);
			   		  }
			   		//{jjtThis.setCoord(begin,when);}
			     )
			   |
			     (
			   		Arguments()
			   		//{jjtThis.setCoord(begin,begin);}
			     )
			   /*|
			     (
			   		TemplateLiteral()
			   		|
					((Identifier() [LOOKAHEAD(Arguments())Arguments()]) #CompositeReference(>1))
			   		{jjtThis.setWhen("inside");}
			   		//{jjtThis.setCoord(begin,begin);}
			     ) */
			   )
		 )
	   |
	     (
	       begin = <REPLACE> ConditionalExpression()
//	           (
//	             TemplateLiteral()
//			   |
//			   	 ((Identifier() [LOOKAHEAD(Arguments())Arguments()]) #CompositeReference(>1))
//			   )
	   		   {
			     setNamed(jjtThis, "when", begin); 
	   		     //jjtThis.setWhen(begin.image);
	   		     }
	   		   //{jjtThis.setCoord(begin,begin);}
	     )
	   )
	}
 
	/** Perform
	 * Perform an action over the join point
	 **/
	void Perform() #Perform:
	{Token action, begin, end, t;}
	{
		begin=<EXEC>
		[LOOKAHEAD(< IDENTIFIER_NAME > < COLON > ) t=< IDENTIFIER_NAME > < COLON >{
		  set(jjtThis, t);
		  //jjtThis.setVariable(t.image);
		  } ]
		action=getNoReservedIdentifier()
 		{set(jjtThis, action);
 		  //jjtThis.setAction(action.image);
 		  }
		//{jjtThis.setCoord(begin,action);}
	   	[
	   			(TemplateLiteral()) #FunctionCallParameters
			| 
	   			Arguments()
	   	]
	}

	/** Perform
	 * Perform an action over the join point
	 **/
	void ExecOnAssign() #Perform:
	{Token action, begin, end, t;}
	{
		<EXEC>
		//[LOOKAHEAD(< IDENTIFIER_NAME > < COLON > ) t=< IDENTIFIER_NAME > < COLON >{jjtThis.setVariable(t.image);} ]
		action=getNoReservedIdentifier()
 		{
 		  set(jjtThis, action);
 		  //jjtThis.setAction(action.image);
 		  }
		//{jjtThis.setCoord(begin,action);}
	   	(	   	  
	   			(TemplateLiteral()) #FunctionCallParameters
			| 
	   			Arguments()
	  	)
	}
	

// 	void CodeLiteralOnlyArgument()  #FunctionCallParameters: {}
//	{
//		TemplateLiteral()
//	}
	
	/** Output
	 * Similar to Insert, however it is used to output in runtime
	 **/
	 void OutputAct() #OutputAct:
	 {Token begin;}
	{
	   begin=<OUTPUT_ACT>
	   	(
	   	  (
	   	    	TemplateLiteral()
	   	    |
	   	    	((Identifier() [LOOKAHEAD(Arguments())Arguments()]) #CompositeReference(>1))
	   	   )
	   |
	   		Arguments()
	     )
	   //{jjtThis.setCoord(begin,begin);}
	}
	
	/** Define
	 *  Assign a value to a join point attribute
	 **/
	void Define() #Define:
	{Token begin;}
	{
		begin=<DEFINE>

		(
		  	noReservedIdentifier() <ASSIGN> AssignmentExpression()
		|
			Arguments()
		)
		//{jjtThis.setCoord(begin,begin);}
	}

	/** Condition
	 *  Boolean expression that verifies if the apply can take place in a join point
	 **/
	void Condition() #Condition:
	{Token t,begin, end;}
	{
	 [ t=<IDENTIFIER_NAME> <COLON> { jjtThis.jjtSetValue(t.image); } ]
	 		begin=<CONDITION> [<FOR> (Identifier() (<COMMA> Identifier())*  ) #For]
	  LogicalORExpression()
	  end=<END>
	 //{jjtThis.setCoord(begin,end);}
	}

/*******************************************************************************
 **********************   END OF LARA SYNTACTIC GRAMMAR    ********************* 
 *******************************************************************************/

	/* The following part of the grammar is the EcmaScript grammar created by The Dojo Foundation (2004-2005), and it was partially updated to conform to the requirements of LARA grammar, such as the use of actions and join point variables.
	**/

	/* Section 11.1: Primary Expressions */

	void PrimaryExpression() #void :
	{}
	{
	    This()		 
		| ObjectLiteral()
		| ArrayLiteral()
		| ParenExpression()
		| Identifier()
		| Literal()
//		{ return jjtThis; }
	}

	void This() #ThisReference:
	{}
	{
	  "this" #ThisReference
	  
	}

	void ParenExpression() #ParenExpression:
	{}
	{
	  "(" Expression() ")" 
	}

	/* Section 7.8: Literals */

	void Literal() #Literal :
	{
	  Token t;
	  Map objLiteral;
	  List arrayLiteral;
	}
	{
		t = <DECIMAL_LITERAL> 
		{
		    set(jjtThis, t);		  
			//jjtThis.setDecimalValue(t.image);
			//if(t.image.contains("."))
			//	jjtThis.setType(Types.Float);
			//else jjtThis.setType(Types.Int);
		}
	|
		t = <HEX_INTEGER_LITERAL>
		{
		    set(jjtThis, t);
			//jjtThis.setHexValue(t.image);
			//jjtThis.setType(Types.Int);
		}
	|
		t = <STRING_LITERAL>
		{
		    set(jjtThis, t);		  
			//jjtThis.setStringValue(t.image);
			//jjtThis.setType(Types.String);
		}
	|
		t = <BOOLEAN_LITERAL>
		{
		    set(jjtThis, t);		  
			//jjtThis.setBooleanValue(t.image);
			//jjtThis.setType(Types.Boolean);
		}
	|
		t = <NULL_LITERAL>
		{
		    set(jjtThis, t);
			//jjtThis.setNullValue();
			//jjtThis.setType(Types.Null);
		}
	| 
		t = <REGULAR_EXPRESSION_LITERAL>
		{
		    set(jjtThis, t);
			//jjtThis.setRegexValue(t.image);
			//jjtThis.setType(Types.RegEx);
		}
	| 
		t = <CODE_LITERAL>
		{
		  	set(jjtThis, t);
			//jjtThis.setCodeValue(t.image);
			//jjtThis.setType(Types.Code);
		}
	}

	void TemplateLiteral() #Literal:
	{
	  Token t;
	}
	{
	  t = <STRING_LITERAL>
		{
		  	set(jjtThis, t);
			//jjtThis.setStringValue(t.image);
			//jjtThis.setType(Types.String);
		}
	  | 
		t = <CODE_LITERAL>
		{
		  	set(jjtThis, t);
			//jjtThis.setCodeValue(t.image);
			//jjtThis.setType(Types.Code);
		}
	}


	void Identifier() #Identifier :
	{
	  Token t;
	}
	{
	  t=<IDENTIFIER_NAME>
	  {
	    jjtThis.jjtSetValue(t.image);
	   /*{jjtThis.setCoord(t,t); }*/
	  }
	}


	void LabelIdentifier() #Identifier :
	{
	  Token t;
	}
	{
	  (
	    t=<LABEL_IDENTIFIER> | t=< IDENTIFIER_NAME>)
	  {
	    jjtThis.jjtSetValue(t.image);
	   /*{jjtThis.setCoord(t,t); }*/
	  }
	}

	/* Section 11.1.4: Array Initialiser */

	void ArrayLiteral() #ArrayLiteral : 
	{}
	{
		"[" ( 
				(ElisionFirst())? 
				(
				  ElementList()
					 //LOOKAHEAD(ElementList() Elision()) ElementList() Elision() 
					//| ( ElementList() )?
				)?
		) "]"
	}		 



	void ElementList() #void :
	{}
	{
		AssignmentExpression()
		
	    (	    LOOKAHEAD(2)
	    	Elision() 	  	    AssignmentExpression()	  	)*	    [Elision()]
		//(Elision() AssignmentExpression() )*
		//(Elision())?
	}

	void Elision() #void:
	{}
	{
	  	(",")
		[("," {inc(jjtThis);/*jjtThis.inc();*/})+ #EmptyPositions]
	}


	void ElisionFirst() #EmptyPositions:
	{}
	{
	  	(","){inc(jjtThis);/*jjtThis.inc();*/}
		[("," {inc(jjtThis);/*jjtThis.inc();*/})+ ]
	}

	/* Section 11.1.5: Object Initialiser */

	void ObjectLiteral() #ObjectLiteral :
	{}
	{
		< LBRACE > {exprBraceCount++;}
			( PropertyNameAndValueList() )?
		< RBRACE > {exprBraceCount--;}
	}

	void PropertyNameAndValueList() #void :
	{}
	{
		
		PropertyNameAndValue() ( LOOKAHEAD( "," PropertyNameAndValue()) "," PropertyNameAndValue() | "," )* 
	}

	void PropertyNameAndValue() #LiteralField :
	{}
	{
		PropertyName() ":" AssignmentExpression()
	}

	void PropertyName() #void :
	{}
	{
		    noReservedIdentifier() 
		  | 
		  	Literal()
	  /* OLD
		Identifier() 
		| 
		<STRING_LITERAL> #Literal
		| 
		<DECIMAL_LITERAL> #Literal
		*/
	}


	/* Section 11.2: Left-Hand-Side Expressions */

	void MemberExpression() #void :
	{}
	{ 
		( (
		  		LOOKAHEAD("function*") GeneratorFunctionExpression() |
				LOOKAHEAD("function") FunctionExpression()|
				PrimaryExpression()  
		) (LOOKAHEAD(2) MemberExpressionPart())*	 ) #CompositeReference(>1)
		|	 AllocationExpression()
	}

	void MemberExpressionForIn() #void :
	{}
	{ 
		( (
				LOOKAHEAD("function*") GeneratorFunctionExpression() |		  
				LOOKAHEAD("function") FunctionExpression() |
				PrimaryExpression()  
		) (LOOKAHEAD(2) MemberExpressionPart())*	 ) #CompositeReference(>1)
	}

	void AllocationExpression() #AllocationExpression :
	{}
	{
		( "new" MemberExpression() ( (LOOKAHEAD(Arguments()) Arguments() (LOOKAHEAD(2) MemberExpressionPart())* ) * ) ) #CompositeReference(>1)
	}

	void MemberExpressionPart() #void :
	{}
	{
		( ("[" Expression() "]")  | (< LBRACE > {exprBraceCount++;} Expression() < RBRACE > {exprBraceCount--;})) #PropertyValueReference | ( "." (noReservedIdentifier())) #PropertyIdentifierReference

	}

	void CallExpression() #CompositeReference(>1) : 
	{}
	{
		MemberExpression() Arguments() ( LOOKAHEAD(2) CallExpressionPart() )*
	}

	void CallExpressionForIn() #CompositeReference(>1) : 
	{}
	{
		MemberExpressionForIn() Arguments() ( LOOKAHEAD(2) CallExpressionPart() )*
	}

	void CallExpressionPart() #void :
	{}
	{
		Arguments() | ( "[" Expression() "]" ) #PropertyValueReference | ( "." noReservedIdentifier() ) #PropertyIdentifierReference
	}

	void Arguments() #FunctionCallParameters :
	{}
	{
		"(" (LOOKAHEAD(getNoReservedIdentifier() <COLON>) (NamedArgumentList(){ set(jjtThis, true);/*jjtThis.areNamed = true;*/})
															| ArgumentList())? ")"
	}

	void NamedArgumentList() #void:
	{}
	{
		 NamedArgument() (<COMMA> NamedArgument())*
	}

	void NamedArgument() #NamedArgument:
	{Token argument;}
	{
	  argument=getNoReservedIdentifier() {jjtThis.jjtSetValue(argument.image);}
	   <COLON> AssignmentExpression()
	}
	void ArgumentList() #void :
	{}
	{
		AssignmentExpression() ("," AssignmentExpression())*
	}


	void LeftHandSideExpression() #void : 
	{}
	{
		LOOKAHEAD(MemberExpression() "(") CallExpression() | MemberExpression() 
	}


	void LeftHandSideExpressionForIn() #void : 
	{}
	{
		LOOKAHEAD(CallExpression()) CallExpressionForIn() | MemberExpressionForIn() 
	}

	/* Section 11.3 Postfix Expressions */

	void PostfixExpression() #PostfixExpression(>1) :
	{}
	{
		LeftHandSideExpression() [ LOOKAHEAD(1) PostfixOperator() ]
	}

	void PostfixOperator() #Operator :
	{Token op;}
	{
		( op="++" | op="--")
		{ jjtThis.jjtSetValue(op.image); }
	} 


	/* Section 11.4 Unary Operators */

	void UnaryExpression() #UnaryExpression(>1) :
	{}
	{ 
		PostfixExpression() | ( UnaryOperator() UnaryExpression() )
	}

	void UnaryOperator() #Operator :
	{Token op;}
	{
		(op="delete" | op="void" | op="typeof" | op="++" | op="--" | op="+" | op="-" | op="~" | op="!")
		{ jjtThis.jjtSetValue(op.image);}
	}


	/* Section 11.5: Multiplicative Operators */


	void MultiplicativeExpression() #BinaryExpressionSequence(>1) :
	{}
	{ 
		UnaryExpression() ( MultiplicativeOperator() UnaryExpression() )*
	}


	void MultiplicativeOperator() #Operator :
	{Token op;}
	{
		(op="*" | op=<SLASH> | op="%") { jjtThis.jjtSetValue(op.image);}
	}

	/* Section 11.6: Additive Operators */

	void AdditiveExpression() #BinaryExpressionSequence(>1) : 
	{}
	{
		MultiplicativeExpression() ( LOOKAHEAD(1) AdditiveOperator() MultiplicativeExpression())*
	}

	void AdditiveOperator() #Operator :
	{Token op;}
	{
		(op="+" | op="-") { jjtThis.jjtSetValue(op.image);}
	}


	/* Section 11.7: Bitwise Shift Operators */

	void ShiftExpression() #BinaryExpressionSequence(>1) :
	{}
	{
		AdditiveExpression() ( ShiftOperator() AdditiveExpression() )*
	}

	void ShiftOperator() #Operator :
	{Token op;}
	{
		(op="<<" | op=">>" | op=">>>")
		{ jjtThis.jjtSetValue(op.image); }
	}

	/* Section 11.4: Relational Operators */

	void RelationalExpression() #BinaryExpressionSequence(>1) :
	{}
	{
		ShiftExpression() ( RelationalOperator() ShiftExpression() )*
	}

	void RelationalOperator() #Operator :
	{Token op;}
	{
		(op="<" | op=">" | op="<=" | op=">=" | op="instanceof" | op="in")
		{ jjtThis.jjtSetValue(op.image); }
	}

	void RelationalExpressionNoIn() #BinaryExpressionSequence(>1) :
	{}
	{
		ShiftExpression() ( RelationalNoInOperator() ShiftExpression() )*
	}


	void RelationalNoInOperator() #Operator :
	{Token op;}
	{
		(op="<" | op=">" | op="<=" | op=">=" | op="instanceof")
		{ jjtThis.jjtSetValue(op.image); }
	}

	/* Section 11.9: Equality Operators */

	void EqualityExpression() #BinaryExpressionSequence(>1) :
	{}
	{
		RelationalExpression() ( EqualityOperator() RelationalExpression() )*
	}

	void EqualityExpressionNoIn() #BinaryExpressionSequence(>1) :
	{}
	{
		RelationalExpressionNoIn() ( EqualityOperator() RelationalExpressionNoIn())*
	}

	void EqualityOperator() #Operator :
	{Token op;}
	{
		(op="==" | op="!=" | op="===" | op="!==" | op=<MATCH>) { jjtThis.jjtSetValue(op.image);}
	}

	/* Section 11.10: Binary Bitwise Operators */

	void BitwiseANDExpression() #BinaryExpressionSequence(>1) :
	{}
	{
		EqualityExpression() ( BitwiseANDOperator() EqualityExpression())*
	}

	void BitwiseANDExpressionNoIn() #BinaryExpressionSequence(>1) :
	{}
	{
		EqualityExpressionNoIn() (BitwiseANDOperator() EqualityExpressionNoIn())*
	}

	void BitwiseANDOperator() #Operator :
	{Token op;}
	{
		op="&" { jjtThis.jjtSetValue(op.image); }
	}

	void BitwiseXORExpression() #BinaryExpressionSequence(>1) :
	{}
	{
		BitwiseANDExpression() (BitwiseXOROperator() BitwiseANDExpression())*
	}

	void BitwiseXORExpressionNoIn() #BinaryExpressionSequence(>1) :
	{}
	{
		BitwiseANDExpressionNoIn() (BitwiseXOROperator() BitwiseANDExpressionNoIn())*
	}

	void BitwiseXOROperator() #Operator :
	{Token op;}
	{
		op="^" { jjtThis.jjtSetValue(op.image); }
	}

	void BitwiseORExpression() #BinaryExpressionSequence(>1) :
	{}
	{
		BitwiseXORExpression() (BitwiseOROperator() BitwiseXORExpression())*
	}

	void BitwiseORExpressionNoIn() #BinaryExpressionSequence(>1) :
	{}
	{
		BitwiseXORExpressionNoIn() (BitwiseOROperator() BitwiseXORExpressionNoIn())*
	}

	void BitwiseOROperator() #Operator :
	{Token op;}
	{
		op="|" { jjtThis.jjtSetValue(op.image); }
	}
	/* Section 11.11: Binary Logical Operators */

	void LogicalANDExpression() #AndExpressionSequence(>1) :
	{}
	{
		BitwiseORExpression() (LogicalANDOperator() BitwiseORExpression())*
	}

	void LogicalANDExpressionNoIn() #AndExpressionSequence(>1) :
	{}
	{ 
		BitwiseORExpressionNoIn() (LogicalANDOperator() BitwiseORExpressionNoIn())*
	}

	void LogicalANDOperator() #Operator :
	{Token op;}
	{
		op="&&" { jjtThis.jjtSetValue(op.image); }
	}

	void LogicalORExpression() #OrExpressionSequence(>1) :
	{}
	{
		LogicalANDExpression() (LogicalOROperator() LogicalANDExpression())*
	}

	void LogicalORExpressionNoIn() #OrExpressionSequence(>1) :
	{}
	{
		LogicalANDExpressionNoIn() (LogicalOROperator() LogicalANDExpressionNoIn())*
	}

	void LogicalOROperator() #Operator :
	{Token op;}
	{
		op="||" { jjtThis.jjtSetValue(op.image); }
	}

	/* Section 11.12: Conditional Operator */

	void ConditionalExpression() #ConditionalExpression(>1) :
	{}
	{
		LogicalORExpression() [ "?" AssignmentExpression() ":" AssignmentExpression() ]
	}

	void ConditionalExpressionNoIn() #ConditionalExpression(>1) :
	{}
	{
		LogicalORExpressionNoIn() [ "?" AssignmentExpression() ":" AssignmentExpressionNoIn() ]
	}


	/* Section 11.13: Assignment Operators */

	void AssignmentExpression() #AssignmentExpression(>1) :
	{}
	{
		LOOKAHEAD(LeftHandSideExpression() AssignmentOperator()) LeftHandSideExpression() AssignmentOperator()
		 (LOOKAHEAD(ActionOnAssign())ActionOnAssign() |AssignmentExpression()) 
		| ConditionalExpression() 
	}

	void AssignmentExpressionNoIn() #AssignmentExpression(>1) : 
	{}
	{
		LOOKAHEAD(LeftHandSideExpression() AssignmentOperator())

		  LeftHandSideExpression() AssignmentOperator()
		  	(LOOKAHEAD(ActionOnAssign())ActionOnAssign() | AssignmentExpressionNoIn())
		| ConditionalExpressionNoIn() 
	}

	void AssignmentOperator() #Operator :
	{Token op;}
	{
		(op="=" | op="*=" | op=<SLASHASSIGN> | op="%=" | op="+=" | op="-=" | op="<<=" | op=">>=" | op=">>>=" | op="&=" | op="^=" | op="|=")
		{ jjtThis.jjtSetValue(op.image); }
	}


	/* Section 11.14: Comma Operator */

	void Expression() #ExpressionList(>1) :
	{}
	{
		AssignmentExpression() ( "," AssignmentExpression() )*
	}

	void ExpressionNoIn() :
	{}
	{
		AssignmentExpressionNoIn() ( "," AssignmentExpressionNoIn() )*
	}



	/* Section 12: STATEMENTS */

	void Statement() #void :
	{{exprBraceCount =0;}}
	{
	  
	
			LOOKAHEAD(2) BodiedStatement()
			|
		  	SingleStatement()
//		}catch(ParseException e){
//			e.printStackTrace();
//			throw null;
//		}
	}

	void SingleStatement() #void:
	{}
	{
		try
		{
	    
	  	  SimpleAction()
	 	| LOOKAHEAD(Action())
		 		Action()
	 	| LOOKAHEAD(< CALL > | (< VAR > < IDENTIFIER_NAME > | LeftHandSideExpression() ) <ASSIGN > <CALL >) Call()
		 	| LOOKAHEAD([<RUN >] <CMD >)
		 		Cmd()
	 	| Run() 
		  	//| LOOKAHEAD(Block()) Block()	  
			// | LOOKAHEAD("var" Identifier() ":") JScriptVarStatement() // JScript .NET declaration 
	 		| LOOKAHEAD("var" Identifier())
	 			VariableStatement()
		| EmptyStatement()
			| LOOKAHEAD(ExpressionStatement())
				ExpressionStatement()
			| LOOKAHEAD(Identifier() ":")
				LabelledStatement()
		| ContinueStatement()
		| YieldStatement()
		| BreakStatement()
		| ImportStatement()
		| ReturnStatement()
		}catch(ParseException e){
	      	error_skipto(e,SEMICOLON);
		}catch(TokenMgrError error){
			exceptions.add(error);
			if (exceptions.size() >= MAXIMUM_SYNTAX_EXCEPTIONS) {
                //Exception e = new larac.exceptions.LARACompilerException("Lexer problems", error);
                error_skipto(new ParseException(error.getMessage()), SEMICOLON);
            }
            
//	      	error_skipto(new ParseException(e.getMessage()),SEMICOLON);
//			Exception e = new larac.exceptions.LARACompilerException("Lexer problems",error);
//			exceptions.add(error);
//	      	throw ;
		}
		  
	}

	void BodiedStatement() #void:
	{}
	{
		try{
	    
			Block()
			| IfStatement()
			| IterationStatement()
			| SwitchStatement()
		| WithStatement()
		| ThrowStatement()
		| TryStatement()
	  	}catch(ParseException e){
	      	error_skipto(e,LBRACE);
	}
	}
 
	/* 12.1 Block Statement */

	void Block() #Block :
	{Token begin, end;}
	{
		begin=< LBRACE >
			( StatementList() )?
		end=< RBRACE >
		//{jjtThis.setCoord(begin,end);}
		}

	void StatementList() #StatementList(>1) : 
	{}
	{
		( Statement() )+
	}


	/* Section 12.2: Variable statement */

	void VariableStatement() #VariableStatement :
	{Token begin, end;}
	{
	  
		begin=< VAR > VariableDeclarationList() end=EndStatement() 
		//{ jjtThis.setCoord(begin,end);}
	
		}

	void VariableDeclarationList() #VariableDeclarationList(>1) :
	{}
	{
		VariableDeclaration() ( "," VariableDeclaration() )*
	}

	void VariableDeclarationListNoIn() #VariableDeclarationList(>1) :
	{}
	{
		VariableDeclarationNoIn() ( "," VariableDeclarationNoIn() )*
	}

	void VariableDeclaration() #VariableDeclaration :
	{Token type;}
	{
//		Identifier() ( Initialiser() )?
		Identifier()[":" type=getNoReservedIdentifier() {
		  set(jjtThis, type);
		  //jjtThis.setType(type.image);
		  }] ( Initialiser() )?
	}

	void VariableDeclarationNoIn() :
	{}
	{
		Identifier() ( InitialiserNoIn() )? #EmptyExpression(jjtree.nodeArity()==0)
	}

	void Initialiser() #void :
	{}
	{
		"=" (LOOKAHEAD(ActionOnAssign() ) ActionOnAssign()   | AssignmentExpression())
	}

	void InitialiserNoIn() #void :
	{}
	{
		"=" AssignmentExpressionNoIn()
	}


	/* Section 12.3: Empty Statement */

	void EmptyStatement() #EmptyStatement :
	{}
	{
		";"
	}


	/* Section 12.4: Expression Statement */

	void ExpressionStatement() #ExpressionStatement :
	{}
	{
		Expression() EndStatement()
	}

	ASTExpressionStatement ParseExpression() #ExpressionStatement :
	{}
	{
		//Expression() <EOF> //To many things! just need a parser like the LeftHandSideExpression rule
		//This is a simpler version, which is just what we need 
		(
		  LOOKAHEAD(MemberExpression() "(") CallExpression()
		  | MemberExpression()
		)
		<EOF >
		{return jjtThis;}	
	}


	/* Section 12.5: The if Statement */

	void IfStatement() #IfStatement :
	{Token begin;}
	{
		begin="if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]
		//{jjtThis.setCoord(begin,begin);	}
	}


	/* Section 12.6: Iteration Statements */
	void IterationStatement() #void :
	{Token begin;Token end;}
	{
		  DoStatement()
		| WhileStatement()
		| ForStatement()
	}

	void DoStatement() #DoStatement:
	{Token begin, end;}
	{
	  begin=<DO> Statement() end=<WHILE> <LPAREN> Expression() <RPAREN> EndStatement() 
	 // {jjtThis.setCoord(begin,end);}
	}

	void WhileStatement() #WhileStatement:
	{Token begin;}
	{
	  begin=<WHILE> <LPAREN> Expression() <RPAREN> Statement()
	 // {jjtThis.setCoord(begin,begin);}
	}

	void ForStatement() #void:
	{Token begin;boolean isEach = false;}
	{
	  begin=< FOR >(
		<EACH> <LPAREN>( //for each var
			   ("var" VariableDeclarationNoIn() <IN> Expression() <RPAREN> Statement()
			         {
						setNamed(jjtThis, "each", true);
			           //jjtThis.setEach(true);
			           } /*{jjtThis.setCoord(begin,begin);*/) #ForVarInStatement
			   |//for each
			   ( LeftHandSideExpressionForIn() <IN> Expression() <RPAREN> Statement()
			         {
			           setNamed(jjtThis, "each", true);
			           //jjtThis.setEach(true);
			           } /*{jjtThis.setCoord(begin,begin);*/) #ForInStatement
	    )
	  |
		<LPAREN> ( //for ...;...;...
			  LOOKAHEAD( (ExpressionNoIn())? ";") (( ExpressionNoIn() #PreAssignmentList)? #EmptyExpression(jjtree.nodeArity()==0) ";"
																   ( Expression() #ForConditionList)? #EmptyExpression(jjtree.nodeArity()==0) ";"
																   ( Expression() #PostAssignmentList)? #EmptyExpression(jjtree.nodeArity()==0) ")"
																   Statement() /*{jjtThis.setCoord(begin,begin); }*/) #ForStatement 
			|//for var ...;...;...
			  LOOKAHEAD("var" VariableDeclarationList() ";") ("var" VariableDeclarationList() #PreAssignmentList";"
																   ( Expression() #ForConditionList)? #EmptyExpression(jjtree.nodeArity()==0) ";"
																   ( Expression() #PostAssignmentList)? #EmptyExpression(jjtree.nodeArity()==0) <RPAREN>
																   Statement() /*{jjtThis.setCoord(begin,begin);}*/) #ForVarStatement
			| //for var in/of
			  (  "var" VariableDeclarationNoIn() (<IN>|(<OF> {isEach = true;})) Expression() <RPAREN> Statement()
			         {
			           setNamed(jjtThis, "each", isEach);
			           //jjtThis.setEach(isEach);
			           } /*{jjtThis.setCoord(begin,begin); }*/) #ForVarInStatement
			| //for in/of
			  ( LeftHandSideExpressionForIn() (<IN>|(<OF> {isEach = true;})) Expression() <RPAREN> Statement()
			          {
			            setNamed(jjtThis, "each", isEach);
			            //jjtThis.setEach(isEach);
			            }/*{jjtThis.setCoord(begin,begin); }*/) #ForInStatement
	     )
	  )  
	}
	/* Section 12.7: The continue Statement */

	void ContinueStatement() #ContinueStatement :
	{Token begin;}
	{
		begin="continue" ( LOOKAHEAD(LabelIdentifier()) LabelIdentifier() )? EndStatement()
		/*{jjtThis.setCoord(begin,begin); }*/
	}



	/* Section 12.8: The break Statement */

	void BreakStatement() #BreakStatement :
	{Token begin;}
	{
		begin="break"( LOOKAHEAD(LabelIdentifier()) LabelIdentifier() )?  EndStatement()
		/*{jjtThis.setCoord(begin,begin); }*/
	}


	/* Section 12.9 The return Statement */

	void ReturnStatement() #ReturnStatement :
	{}
	{
		"return" ( LOOKAHEAD(Expression()) Expression() )? #EmptyExpression(jjtree.nodeArity()==0) EndStatement() 
	}


	/* Custom */
	void YieldStatement() #YieldStatement :
	{Token begin;}
	{
		begin="yield" ( LOOKAHEAD(Expression()) Expression() )? #EmptyExpression(jjtree.nodeArity()==0) EndStatement()
	}


	/* Section 12.10: The with Statement */

	void WithStatement() #WithStatement :
	{}
	{
		"with" "(" Expression() ")" Statement()
	}


	/* 12.11 The switch Statement */

	void SwitchStatement() #SwitchStatement :
	{Token begin;}
	{
		begin="switch" "(" Expression() ")" CaseBlock()
		/*{jjtThis.setCoord(begin,begin); }*/
	}

	void CaseBlock() #CaseGroups :
	{Token begin,end;}
	{
		begin=< LBRACE > ( CaseClauses() )? 
				( 
						end=< RBRACE > | DefaultClause() ( CaseClauses() )? end=< RBRACE > 
				)
		/*{jjtThis.setCoord(begin,end); }*/
	}

	void CaseClauses() #void :
	{}
	{
		( CaseClause() )+
	}

	void CaseClause()  #CaseGroup :
	{Token begin;}
	{
		( ( begin="case" Expression() ":" ) #CaseGuard ) ( StatementList() )?
		/*{jjtThis.setCoord(begin,begin); }*/
	}

	void DefaultClause() #CaseGroup :
	{Token begin;}
	{
		( ( begin="default" ":" ) #CaseGuard ) ( StatementList() )?
		/*{jjtThis.setCoord(begin,begin); }*/
	}


	/* Section 12.12: Labelled Statements */

	void LabelledStatement() #LabelledStatement: 
	{}
	{
		Identifier() ":" Statement()
	}

	void ThrowStatement() #ThrowStatement :
	{Token begin;}
	{
		begin="throw" Expression() EndStatement()
		/*{jjtThis.setCoord(begin,begin); }*/
	}

	void TryStatement() #TryStatement : 
	{Token begin;}
	{
		begin="try" Block() 
		( 
				( Finally() | Catch() [Finally()])
		)
		/*{jjtThis.setCoord(begin,begin); }*/
	}  

	void Catch() #CatchClause :
	{Token begin;}
	{
		begin="catch" "(" Identifier() ")" Block()
		/*{jjtThis.setCoord(begin,begin); }*/
	}

	void Finally() #FinallyClause :
	{Token begin;}
	{
		begin="finally" Block()
		/*{jjtThis.setCoord(begin,begin); }*/
	}

	/* Section 13: Function Definition */

	void FunctionDeclaration() #FunctionDeclaration :
	{Token begin;}
	{
		begin="function" Identifier() ( "(" ( FormalParameterList() )? ")" ) #FormalParameterList FunctionBody()
		/*{jjtThis.setCoord(begin,begin); }*/ 
	}

	void GeneratorFunctionDeclaration() #GeneratorFunctionDeclaration :
	{Token begin;}
	{
		begin="function*" Identifier() ( "(" ( FormalParameterList() )? ")" ) #FormalParameterList FunctionBody()
		/*{jjtThis.setCoord(begin,begin); }*/ 
	}

	void FunctionExpression() #FunctionExpression :
	{Token begin;}
	{
		begin="function" ( Identifier() )? ( "(" ( FormalParameterList() )? ")" ) #FormalParameterList FunctionBody()
		/*{jjtThis.setCoord(begin,begin); }*/
	}

	void GeneratorFunctionExpression() #GeneratorFunctionExpression :
	{Token begin;}
	{
		begin="function*" ( Identifier() )? ( "(" ( FormalParameterList() )? ")" ) #FormalParameterList FunctionBody()
		/*{jjtThis.setCoord(begin,begin); }*/
	}

	void FormalParameterList() #void :
	{}
	{
		(Identifier()) ( "," (Identifier()) )*
	}

	void FunctionBody() #Block :
	{}
	{
		< LBRACE > (SourceElements())? < RBRACE > 
	}


	/* Section 14: Program *

	ASTProgram Program() #Program :
	{}
	{  
		JavaScript()
				<EOF>
		{ return jjtThis; }
	}
	/**/

	void JavaScript() #JavaScript:
	{}
	{
	  (SourceElements())?
	}


	void SourceElements() #void :
	{}
	{
		(SourceElement())+ 
	}

	void SourceElement() #void :
	{}
	{
		LOOKAHEAD("function*" Identifier()) GeneratorFunctionDeclaration() | LOOKAHEAD("function" Identifier()) FunctionDeclaration() | Statement()
	}


	/*
	 * Grammar for parsing JScript .NET contructs: ( import System; var contents :
	 * String = reader.ReadToEnd(); ) Refer: src/hostenv_jsc.js
	 */

	void ImportStatement():
	{}
	{
		"import" Name() [ "." "*" ] EndStatement()
	}


	void Name():
	{}
	{
		<IDENTIFIER_NAME> ( LOOKAHEAD(2) < DOT > <IDENTIFIER_NAME> )*
	}


	void JScriptVarStatement() #VariableStatement :
	{}
	{
		< VAR > JScriptVarDeclarationList() EndStatement()
	}

	void JScriptVarDeclarationList() #VariableDeclarationList(>1) :
	{}
	{
		JScriptVarDeclaration() ( < COMMA > JScriptVarDeclaration() )*
	}

	void JScriptVarDeclaration() #VariableDeclaration :
	{}
	{
		Identifier() ":" <IDENTIFIER_NAME> ( Initialiser() )? 
	}

	Token EndStatement() #void:
	{Token end;}
	{
		try
		{
			end=< SEMICOLON >
			{return end;}
	
	    }catch(ParseException e)
	    {
	      error_skipto(e, SEMICOLON);
	      /*
			if(e.expectedTokenSet.size() > MAX_EXCEPTION_TOKEN_SIZE
			  || (e.expectedTokenSet.size() == 1  && e.expectedTokenSet.get(0).equals(";"))){
			    
				Token foundToken = getToken(1);
				String line = "at line " + e.currentToken.beginLine + ", column " + e.currentToken.beginColumn;
				String message = line+": did you forget a ';'?";
				if (foundToken != null){
			 		message+=" (possible errant token: "+ foundToken + ")";
				}
			    e = new ParseException(message);
			    SimpleNode currNode = getCurrentNode();
				exceptions.add(e);

				//ParseExceptionData excData = new ParseExceptionData(e);
				// if (currNode != null){
				//	currNode.setExceptionData(excData);
				//}
			}else{
			  error_skipto(e, SEMICOLON);
			}
			
		    */
	    }
	    

	  {return new Token(SEMICOLON);}
	  
	}

JAVACODE
void error_skipto(ParseException e, int kind) {
//  ParseException e = generateParseException();  // generate the exception object.
//  System.out.println(e.toString());  // print the error message
  exceptions.add(e);
  SimpleNode currNode = getCurrentNode();
  //ParseExceptionData excData = new ParseExceptionData(e);
  //excData.setSkippedToToken(kind);
  Token t = null;
//  int braceCount = 0;
  skipper: do {
    Token test = getToken(1);
//    System.out.println(exprBraceCount);
	if(test == null || test.kind == END)
	{	  
//		System.out.println("I'm breaking here with:"+test);
    	break;
    }
	switch(test.kind)
	{
	  case RBRACE: 
	  		exprBraceCount--;
	  		if(exprBraceCount < 0)
	  			break skipper;
	  		break;
	}

    
    t = getNextToken();

    //if(t != null)
   // 	excData.addSkippedToken(t);
//	System.out.println("Skipped: "+t+" token("+test+")");
  } while (t != null && (t.kind != kind && t.kind != EOF));
    // The above loop consumes tokens all the way up to a token of
// "kind".  We use a do-while loop rather than a while because the
// current token is the one immediately before the erroneous token
// (in our case the token immediately before what should have been
// "if"/"while".

	//if (currNode != null){
	// currNode.setExceptionData(excData);
	//}
	if(t == null || t.kind == EOF){
	  	throw new RuntimeException();
		//throw new StopParseException();
	}
}

JAVACODE
void error_noSkip(ParseException e) {
  System.out.println("--------------NO SKIP-----------------"); 
//  ParseException e = generateParseException();  // generate the exception object.
//  System.out.println(e.toString());  // print the error message
  SimpleNode currNode = getCurrentNode();
  //ParseExceptionData excData = new ParseExceptionData(e);
  //  if (currNode != null){
	// currNode.setExceptionData(excData);
  //	}
}