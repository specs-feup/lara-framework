#!/usr/bin/env node

import { readFileSync } from "fs";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import fs from "fs";
import { join } from "path";

function buildInterfaces(inputFileName, outputFileName) {
  console.log("Hello from build-interfaces.js");
  console.log("inputFile:", inputFileName);
  console.log("outputFile:", outputFileName);

  const jsonSpecification = readFileSync(inputFileName, "utf8");
  const specification = JSON.parse(jsonSpecification);

  // Create output file if it doesn't exist
  const outputFile = fs.openSync(outputFileName, "w");
  fs.writeSync(
    outputFile,
    "// This file is generated by build-interfaces.js\n\n"
  );

  let typeNameSet = new Set();
  let joinpointNameSet = new Set();
  let joinpoints = [];
  let enumNameSet = new Set();
  let enums = [];

  specification.children.forEach((child) => {
    typeNameSet.add(child.type);
    if (child.type === "joinpoint") {
      joinpointNameSet.add(child.name);
      joinpoints.push(child);
    }
    if (child.type === "enum") {
      enumNameSet.add(child.name);
      enums.push(child);
    }
  });

  generateJoinpoints(joinpoints, joinpointNameSet, enumNameSet, outputFile);
  generateEnums(enums, outputFile);

  fs.closeSync(outputFile);
  console.log(joinpoints[0].children[0]);
}

function generateJoinpoints(
  joinpoints,
  joinpointNameSet,
  enumNameSet,
  outputFile
) {
  joinpoints.forEach((jp) => {
    generateJoinpoint(jp, outputFile, joinpointNameSet, enumNameSet);
  });
}

function generateJoinpoint(jp, outputFile, joinpointNameSet, enumNameSet) {
  console.log("Generating joinpoint:", jp.name);
  fs.writeSync(
    outputFile,
    `export interface ${capitalizeFirstLetter(jp.name)}${
      jp.extends ? " extends " : ""
    }${interpretType(jp.extends, joinpointNameSet, enumNameSet)} {\n`
  );
  jp.children.forEach((child) => {
    switch (child.type) {
      case "attribute":
        generateJoinpointAttribute(
          child,
          outputFile,
          joinpointNameSet,
          enumNameSet
        );
        break;
      case "action":
        generateJoinpointAction(
          child,
          outputFile,
          joinpointNameSet,
          enumNameSet
        );
        break;
      case "select":
        // Do nothing
        break;
      default:
        console.log("Unknown child type:", child.type);
    }
  });
  fs.writeSync(outputFile, `}\n\n`);
}

function generateJoinpointAttribute(
  attributeObject,
  outputFile,
  joinpointNameSet,
  enumNameSet
) {
  // Ignore deprecated attributes
  if (attributeObject.tooltip?.includes("DEPRECATED")) {
    //console.log("Ignoring deprecated attribute:", attributeObject.tooltip);
    return;
  }

  if (attributeObject.children.length !== 1) {
    //console.log("Attribute has more than one child:", attributeObject);
    generateJoinpointAction(
      attributeObject,
      outputFile,
      joinpointNameSet,
      enumNameSet,
      "get" + capitalizeFirstLetter(attributeObject.children[0].name)
    );
    // TODO
    return;
  }

  const attribute = attributeObject.children[0];
  fs.writeSync(outputFile, `    get ${attribute.name}(): `);

  const type = interpretType(attribute.type, joinpointNameSet, enumNameSet);
  fs.writeSync(outputFile, `${type};\n`);
}

function generateJoinpointAction(
  actionObject,
  outputFile,
  joinpointNameSet,
  enumNameSet,
  overrideName = null
) {
  const action = actionObject.children[0];
  fs.writeSync(outputFile, `    ${overrideName ?? action.name}(`);

  actionObject.children.slice(1).forEach((parameter) => {
    const type = interpretType(parameter.type, joinpointNameSet, enumNameSet);
    let parameterName = parameter.name;
    switch (parameterName) {
      case "function":
        parameterName = "func";
        break;
      case "else":
        parameterName = "elseStatement";
    }
    fs.writeSync(outputFile, `${parameterName}: ${type}, `);
  });
  const type = interpretType(action.type, joinpointNameSet, enumNameSet);
  fs.writeSync(outputFile, `): ${type};\n`);
}

function generateEnums(enums, outputFile) {
  enums.forEach((obj) => {
    generateEnum(obj, outputFile);
  });
}

function generateEnum(e, outputFile) {
  fs.writeSync(outputFile, `enum ${e.name} {\n`);
  e.children.forEach((child) => {
    fs.writeSync(outputFile, `    ${child.value},\n`);
  });
  fs.writeSync(outputFile, `}\n\n`);

  console.log(e);
}

function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function interpretType(typeString, joinpointNameSet, enumNameSet) {
  // Detect array types
  if (typeString.endsWith("[]")) {
    const baseType = typeString.slice(0, -2);
    return `${interpretType(baseType, joinpointNameSet, enumNameSet)}[]`;
  } else if (typeString.startsWith("[")) {
    // Insert quotes arround the possible string literals
    // Example: [abc | asd] to ["abc" | "asd"]
    const literals = typeString
      .slice(1, -1)
      .split("|")
      .map((literal) => `"${literal.trim()}"`)
      .join(" | ");
    return literals;
  }

  if (joinpointNameSet.has(typeString) || enumNameSet.has(typeString)) {
    return capitalizeFirstLetter(typeString);
  }

  switch (typeString) {
    case "Integer":
    case "int":
    case "Long":
    case "Double":
      return "number";
      break;
    case "Map":
      return "Map<string, any>";
    default:
      return typeString.toLowerCase();
      break;
  }
}

const args = yargs(hideBin(process.argv))
  .scriptName("lara-build-interfaces")
  .option("i", {
    alias: "input",
    describe: "Path to JSON config file",
    type: "string",
  })
  .option("o", {
    alias: "output",
    describe: "Path to the output file",
    type: "string",
  })
  .help()
  .showHelpOnFail(true)
  .strict()
  .parse();

buildInterfaces(args.input, args.output);
