#!/usr/bin/env node

import { readFileSync } from "fs";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import fs from "fs";
import {
  convertSpecification,
  capitalizeFirstLetter,
} from "./convert-joinpoint-specification.js";

function buildInterfaces(inputFileName, outputFileName) {
  console.log("Hello from build-interfaces.js");
  console.log("inputFile:", inputFileName);
  console.log("outputFile:", outputFileName);

  const jsonSpecification = readFileSync(inputFileName, "utf8");
  const specification = convertSpecification(JSON.parse(jsonSpecification));

  // Create output file if it doesn't exist
  const outputFile = fs.openSync(outputFileName, "w");
  fs.writeSync(
    outputFile,
    `///////////////////////////////////////////////////
// This file is generated by build-interfaces.js //
///////////////////////////////////////////////////

/* eslint-disable @typescript-eslint/ban-types */
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unsafe-assignment */
/* eslint-disable @typescript-eslint/no-unsafe-call */
/* eslint-disable @typescript-eslint/no-unsafe-member-access */
/* eslint-disable @typescript-eslint/no-unsafe-return */

import JavaTypes from "lara-js/api/lara/util/JavaTypes.js";\n\n`
  );

  generateJoinpoints(specification.joinpoints, outputFile);
  generateEnums(specification.enums, outputFile);

  generateJoinpointWrapper(specification.joinpoints, outputFile);

  fs.closeSync(outputFile);
}

function generateJoinpoints(joinpoints, outputFile) {
  for (const jp of joinpoints) {
    generateJoinpoint(jp, outputFile);
  }
}

function generateJoinpoint(jp, outputFile) {
  fs.writeSync(
    outputFile,
    `${generateDocumentation(jp.tooltip)}export class ${jp.name}${
      jp.extends ? ` extends ${jp.extends}` : ""
    } {\n`
  );
  if (jp.name === "Joinpoint") {
    fs.writeSync(
      outputFile,
      `  _javaObject!: any;
  constructor(obj: any) {
    this._javaObject = obj;
  }\n`
    );
  }

  for (const attribute of jp.attributes) {
    generateJoinpointAttribute(attribute, outputFile);
  }

  // TODO: remove this set as it is here because I can't deal with method overloading
  let actionNameSet = new Set();
  for (const action of jp.actions) {
    if (!actionNameSet.has(action.name)) {
      generateJoinpointAction(action, outputFile);
      actionNameSet.add(action.name);
    }
  }

  fs.writeSync(outputFile, `}\n\n`);
}

function generateDocumentation(tooltip) {
  if (!tooltip) {
    return "";
  }
  return `  /**\n   * ${tooltip.split("\n").join("\n   * ")}\n   */\n`;
}

function generateJoinpointAttribute(attribute, outputFile) {
  fs.writeSync(
    outputFile,
    `${generateDocumentation(attribute.tooltip)}  get ${attribute.name}(): ${
      attribute.type
    } { return ${
      "wrapJoinPoint(this._javaObject.get" +
      capitalizeFirstLetter(attribute.name)
    })() }\n`
  );
}

function generateJoinpointAction(action, outputFile) {
  const parameters = action.parameters
    .map((parameter) => {
      return `${parameter.name}: ${parameter.type}`;
    })
    .join(", ");

  const callParameters = action.parameters
    .map((parameter) => {
      return parameter.name;
    })
    .join(", ");

  fs.writeSync(
    outputFile,
    `${generateDocumentation(action.tooltip)}  ${action.name}(${parameters}): ${
      action.returnType
    } { return wrapJoinPoint(this._javaObject.${
      action.name
    }(${callParameters})); }\n`
  );
}

function generateEnums(enums, outputFile) {
  for (const e of enums) {
    generateEnum(e, outputFile);
  }
}

function generateEnum(e, outputFile) {
  fs.writeSync(outputFile, `export enum ${e.name} {\n`);
  e.entries.forEach((entry) => {
    fs.writeSync(outputFile, `  ${entry},\n`);
  });
  fs.writeSync(outputFile, `}\n\n`);
}

function generateJoinpointWrapper(joinpoints, outputFile) {
  fs.writeSync(
    outputFile,
    `const JoinpointMapper: { [key: string]: typeof Joinpoint } = {\n`
  );
  for (const jp of joinpoints) {
    fs.writeSync(outputFile, `  ${jp.originalName}: ${jp.name},\n`);
  }
  fs.writeSync(outputFile, `};\n`);

  fs.writeSync(
    outputFile,
    `\nexport function wrapJoinPoint(obj: any): any {
  if (obj === undefined) {
    return obj;
  }

  if (obj instanceof Joinpoint) {
    return obj;
  }

  if (typeof obj !== "object") {
    return obj;
  }

  if (Array.isArray(obj)) {
    return obj.map(wrapJoinPoint);
  }

  if (!JavaTypes.isJavaObject(obj)) {
    console.log("Given Java join point is not a Java class: " + typeof obj);
    return obj;
  }

  const isJavaJoinPoint = JavaTypes.JoinPoint.isJoinPoint(obj);
  if (!isJavaJoinPoint) {
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      \`Given Java join point is a Java class but is not a JoinPoint: \${obj.getClass()}\`
    );
  }

  return new JoinpointMapper[obj.getType() as string](obj);
}\n`
  );

  fs.writeSync(
    outputFile,
    `\nexport function unwrapJoinPoint(obj: any): any {
  if (obj instanceof Joinpoint) {
    return obj._javaObject;
  }

  return obj;
}\n`
  );
}

const args = yargs(hideBin(process.argv))
  .scriptName("lara-build-interfaces")
  .option("i", {
    alias: "input",
    describe: "Path to JSON config file",
    type: "string",
  })
  .option("o", {
    alias: "output",
    describe: "Path to the output file",
    type: "string",
  })
  .help()
  .showHelpOnFail(true)
  .strict()
  .parse();

buildInterfaces(args.input, args.output);
